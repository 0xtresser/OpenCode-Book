# 5.2 ToolRegistry: Registration and Discovery

> **Model**: claude-opus-4-6 (anthropic/claude-opus-4-6)
> **Generation Date**: 2025-02-17

---

`ToolRegistry` (`tool/registry.ts`) manages the registration and discovery of all available tools. There are four sources of tools.

## 5.2.1 Built-in Tool Registry

OpenCode ships with 20+ built-in tools, imported directly in `registry.ts`:

```typescript
import { BashTool } from "./bash"
import { EditTool } from "./edit"
import { GlobTool } from "./glob"
import { GrepTool } from "./grep"
import { ReadTool } from "./read"
import { WriteTool } from "./write"
import { TaskTool } from "./task"
import { TodoWriteTool, TodoReadTool } from "./todo"
import { WebFetchTool } from "./webfetch"
import { WebSearchTool } from "./websearch"
import { BatchTool } from "./batch"
import { SkillTool } from "./skill"
import { QuestionTool } from "./question"
import { LspTool } from "./lsp"
import { CodeSearchTool } from "./codesearch"
import { PlanEnterTool, PlanExitTool } from "./plan"
import { ApplyPatchTool } from "./apply_patch"
```

These tools cover all major scenarios: file operations, command execution, code intelligence, networking, and Agent collaboration.

## 5.2.2 Loading Custom Tools from the Project Directory

Users can create custom tools within their project:

```typescript
const glob = new Bun.Glob("{tool,tools}/*.{js,ts}")
const matches = await Config.directories().then(dirs =>
  dirs.flatMap(dir => [
    ...glob.scanSync({ cwd: dir, absolute: true, followSymlinks: true, dot: true })
  ]),
)
```

The scanned paths include:
- `.opencode/tool/*.ts`
- `.opencode/tools/*.ts`

Custom tool format:

```typescript
// .opencode/tools/my-tool.ts
export default {
  description: "My custom tool",
  parameters: z.object({ query: z.string() }),
  async execute(args, ctx) {
    return { title: "Query result", output: "...", metadata: {} }
  }
}
```

## 5.2.3 Loading Tools from Plugins

Plugins can register tools via the `tool` field:

```typescript
const plugins = await Plugin.list()
for (const plugin of plugins) {
  for (const [id, def] of Object.entries(plugin.tool ?? {})) {
    custom.push(fromPlugin(id, def))
  }
}
```

## 5.2.4 MCP Tool Injection

External servers connected via the MCP protocol can also provide tools. These tools are dynamically injected in the Session's `loop()` function. The detailed mechanics of MCP tools will be discussed in Chapter 8.

## 5.2.5 The `fromPlugin()` Adapter

The definition format for plugins and custom tools (`ToolDefinition`) differs slightly from the internal format (`Tool.Info`). `fromPlugin()` handles the conversion:

```typescript
function fromPlugin(id: string, def: ToolDefinition): Tool.Info {
  return Tool.define(id, async (initCtx) => {
    const toolDef = typeof def === "function" ? await def(/* context */) : def
    return {
      description: toolDef.description,
      parameters: z.object(toolDef.parameters),
      async execute(args, ctx) {
        const result = await toolDef.execute(args, /* plugin context */)
        return {
          title: result.title ?? id,
          output: result.output,
          metadata: result.metadata ?? {},
        }
      },
    }
  })
}
```

This ensures that regardless of where a tool comes from -- built-in, custom, Plugin, or MCP -- the Session layer always sees the same unified `Tool.Info` interface.

## 5.2.6 Tool Filtering and Visibility

Not all tools are visible to all Agents. In the `loop()` function, the tool list is filtered based on the Agent's permission rules:

```typescript
// Simplified logic
const allTools = await ToolRegistry.list()
const filteredTools = allTools.filter(tool => {
  const permission = PermissionNext.evaluate(tool.id, "*", agent.permission)
  return permission.action !== "deny"
})
```

Some tools are marked as `hidden` (such as `plan-enter` and `plan-exit`) and do not appear in the tool list; they are only enabled under specific conditions.
