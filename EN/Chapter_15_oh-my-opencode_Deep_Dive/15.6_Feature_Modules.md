# 15.6 Feature Modules

> **Model**: claude-opus-4-6 (anthropic/claude-opus-4-6)
> **Generation Date**: 2026-02-17

---

The `features/` directory of oh-my-opencode contains 20 independent feature modules, each encapsulating a complete functional domain. This section provides an in-depth analysis of the most critical modules.

## 15.6.1 Background Agent System (`features/background-agent/`)

The background Agent system is the most complex Feature module in oh-my-opencode, comprising 33 source files. It implements asynchronous parallel sub-Agent management -- the main Agent can dispatch subtasks to the background without blocking itself.

### Architecture Components

```
background-agent/
├── spawner.ts                    # Sub-session creator
├── spawner/                      # Creator submodules
├── manager.ts                    # Background task manager
├── task-poller.ts                # Task poller
├── concurrency.ts                # Concurrency controller
├── parent-session-notifier.ts    # Parent session notifier
├── parent-session-context-resolver.ts  # Parent session context resolver
├── result-handler.ts             # Result handler
├── session-idle-event-handler.ts # Session idle event handler
├── session-output-validator.ts   # Output validator
├── error-classifier.ts           # Error classifier
├── state.ts                      # State management
├── types.ts                      # Type definitions
└── ...
```

### Spawner: Sub-Session Creator

The Spawner is responsible for creating sessions for background sub-Agents:

```typescript
// oh-my-opencode/src/features/background-agent/spawner.ts
export function createTask(input: LaunchInput): BackgroundTask {
  return {
    id: `bg_${crypto.randomUUID().slice(0, 8)}`,  // 8-character unique ID
    status: "pending",
    queuedAt: new Date(),
    description: input.description,
    prompt: input.prompt,
    agent: input.agent,
    parentSessionID: input.parentSessionID,
    parentMessageID: input.parentMessageID,
    parentModel: input.parentModel,
    parentAgent: input.parentAgent,
    model: input.model,
  }
}

export async function startTask(item: QueueItem, ctx: SpawnerContext): Promise<void> {
  const { task, input } = item

  // Get the parent session's working directory
  const parentSession = await client.session.get({ path: { id: input.parentSessionID } })
  const parentDirectory = parentSession?.data?.directory ?? directory

  // Get tool permission restrictions for the Agent
  const restrictions = getAgentToolRestrictions(input.agent)

  // Create a new session and send the prompt
  const response = await promptWithModelSuggestionRetry(client, {
    path: {}, // Empty path means create a new session
    body: {
      parts: [{ type: "text", text: input.prompt }],
      agent: input.agent,
      model: input.model,
    },
    query: { directory: parentDirectory },
  })

  // Notify the tmux manager
  if (onSubagentSessionCreated) {
    await onSubagentSessionCreated({
      sessionID: response.sessionID,
      parentID: input.parentSessionID,
      title: input.description,
    })
  }
}
```

### Concurrency: Concurrency Control

The concurrency controller uses a **semaphore pattern** to manage the number of simultaneously running background tasks:

```typescript
// oh-my-opencode/src/features/background-agent/concurrency.ts
export class ConcurrencyManager {
  private counts: Map<string, number> = new Map()   // Current concurrency per model
  private queues: Map<string, QueueEntry[]> = new Map()  // Wait queues

  getConcurrencyLimit(model: string): number {
    // Priority: model-level limit > provider-level limit > default limit
    const modelLimit = this.config?.modelConcurrency?.[model]
    if (modelLimit !== undefined) return modelLimit === 0 ? Infinity : modelLimit

    const provider = model.split('/')[0]
    const providerLimit = this.config?.providerConcurrency?.[provider]
    if (providerLimit !== undefined) return providerLimit === 0 ? Infinity : providerLimit

    return this.config?.defaultConcurrency ?? 5  // Default concurrency: 5
  }

  async acquire(model: string): Promise<void> {
    const limit = this.getConcurrencyLimit(model)
    const current = this.counts.get(model) ?? 0

    if (current < limit) {
      this.counts.set(model, current + 1)
      return  // Below limit, acquire immediately
    }

    // At limit, enter wait queue
    return new Promise<void>((resolve, reject) => {
      const queue = this.queues.get(model) ?? []
      queue.push({ resolve, rawReject: reject, settled: false })
      this.queues.set(model, queue)
    })
  }

  release(model: string): void {
    // Release a slot and wake the next waiter in the queue
    const queue = this.queues.get(model)
    if (queue?.length) {
      const next = queue.shift()!
      next.settled = true
      next.resolve()
    } else {
      const current = this.counts.get(model) ?? 0
      this.counts.set(model, Math.max(0, current - 1))
    }
  }
}
```

Concurrency control supports three levels of configuration granularity:

```jsonc
{
  "background_task": {
    "defaultConcurrency": 5,              // Global default
    "providerConcurrency": {
      "anthropic": 2,                     // Anthropic: max 2
      "openai": 10                        // OpenAI: max 10
    },
    "modelConcurrency": {
      "anthropic/claude-opus-4-6": 1      // Opus: max 1
    }
  }
}
```

### Parent Session Notification

When a background task completes, the notifier sends a result summary to the parent session. This implements an **asynchronous notification pattern** -- the main Agent does not need to poll the status of background tasks; instead, it passively receives notifications when tasks complete.

## 15.6.2 Boulder State Management (`features/boulder-state/`)

Boulder State is a conceptual module -- it manages Sisyphus's "boulder," i.e., the work plan currently being executed.

```typescript
// oh-my-opencode/src/features/boulder-state/types.ts
export interface BoulderState {
  active_plan: string     // Absolute path of the active plan file
  started_at: string      // ISO timestamp of work start
  session_ids: string[]   // All session IDs participating in this plan
  plan_name: string       // Plan name derived from the filename
  agent?: string          // Agent type to use for recovery
}

export interface PlanProgress {
  total: number           // Total number of checklist items
  completed: number       // Number of completed checklist items
  isComplete: boolean     // Whether all items are complete
}
```

Boulder State enables the boulder's state to **persist across sessions**. When the user closes OpenCode and reopens it, Sisyphus can resume the previous work plan and continue "pushing the boulder."

## 15.6.3 Claude Tasks System (`features/claude-tasks/`)

Claude Tasks is a structured task management system that is more powerful than OpenCode's built-in Todo system. It supports task creation, updates, list viewing, and status tracking, and is exposed to the Agent through a dedicated `task` tool.

## 15.6.4 Built-in Skill System (`features/builtin-skills/`)

oh-my-opencode includes 5 built-in Skills:

```
builtin-skills/
├── git-master/       # Enhanced Git operations
├── frontend-ui-ux/   # Frontend UI/UX design guidance
├── dev-browser/       # Browser automation development
├── agent-browser/     # Agent browser
└── skills/            # Skill registration and loading
```

Each Skill is essentially a carefully crafted Markdown document containing expert-level guidance for a specific domain. For example, the `git-master` Skill includes Git operation best practices, atomic commit conventions, rebase/squash strategies, and more.

These Skills are injected into sub-Agents via the `load_skills` parameter:

```typescript
task(
  category="quick",
  load_skills=["git-master"],  // Inject Git expert knowledge
  prompt="Create an atomic commit for the auth changes"
)
```

## 15.6.5 Built-in Command System (`features/builtin-commands/`)

oh-my-opencode provides a set of built-in slash commands:

```
builtin-commands/
├── commands.ts        # Command definitions
├── templates/         # Command templates
└── types.ts
```

Typical built-in commands include:

- `/init-deep`: Initialize a hierarchical AGENTS.md knowledge base
- `/ralph-loop`: Start the self-driven work loop
- `/ulw-loop`: Start the ultrawork mode loop
- `/start-work`: Launch a work session from a Prometheus plan
- `/refactor`: Intelligent refactoring command
- `/handoff`: Create a context handoff summary

## 15.6.6 tmux Sub-agent Management (`features/tmux-subagent/`)

tmux sub-Agent management is a visualization feature of oh-my-opencode -- when background Agents are running, they are displayed in real-time in tmux split panes, allowing users to visually observe the working status of multiple Agents.

### Decision Engine

`decision-engine.ts` is the core of tmux management. It decides when to create new panes, how to split space, and when to close panes:

```typescript
// oh-my-opencode/src/features/tmux-subagent/decision-engine.ts
export {
  calculateCapacity,     // Calculate current pane capacity
  computeGridPlan,       // Compute grid layout plan
  mapPaneToSlot,         // Map panes to grid slots
} from "./grid-planning"

export {
  canSplitPane,          // Check if a pane can be split
  getBestSplitDirection, // Get optimal split direction
  findMinimalEvictions,  // Find minimum eviction plan
} from "./pane-split-availability"

export { findSpawnTarget } from "./spawn-target-finder"
export { decideCloseAction, decideSpawnActions } from "./spawn-action-decider"
```

### Grid Layout Planning

`grid-planning.ts` treats the tmux window as a **grid** and automatically calculates the optimal pane splitting scheme:

```
┌────────────────────┬──────────┐
│                    │ Explore  │
│     Sisyphus       ├──────────┤
│     (Main Agent)   │ Librarian│
│                    ├──────────┤
│                    │ Oracle   │
└────────────────────┴──────────┘
     Main pane (60%)   Sub-panes (40%)
```

Configuration parameters control layout proportions:

```jsonc
{
  "tmux": {
    "enabled": true,
    "layout": "main-vertical",
    "main_pane_size": 60,            // Main pane occupies 60%
    "main_pane_min_width": 120,      // Minimum width: 120 columns
    "agent_pane_min_width": 40       // Sub-pane minimum: 40 columns
  }
}
```

## 15.6.7 Skill MCP Manager (`features/skill-mcp-manager/`)

The Skill MCP Manager manages the lifecycle of embedded MCP services declared in Skill files. When a Skill declares that it needs a specific MCP service (such as Context7), the Manager is responsible for starting the MCP process, maintaining the connection, and cleaning up resources when they are no longer needed.

## 15.6.8 MCP OAuth (`features/mcp-oauth/`)

Handles the authentication flow for MCP services that require OAuth authentication.

## 15.6.9 Context Injector (`features/context-injector/`)

A general-purpose context injector that provides other modules with the foundational capability to inject context information into Agent messages.

### Other Feature Modules

| Module | Function |
|--------|----------|
| `claude-code-agent-loader` | Loads Agent definitions in Claude Code format |
| `claude-code-command-loader` | Loads Commands in Claude Code format |
| `claude-code-mcp-loader` | Loads MCP configurations in Claude Code format |
| `claude-code-plugin-loader` | Loads Plugins in Claude Code format |
| `claude-code-session-state` | Manages Claude Code-compatible session state |
| `opencode-skill-loader` | Loads OpenCode Skill files |
| `run-continuation-state` | Manages continuation state for `oh-my-opencode run` |
| `task-toast-manager` | Manages task-related Toast notifications |
| `tool-metadata-store` | Stores tool metadata (descriptions, usage statistics, etc.) |
| `hook-message-injector` | Injects additional information into Hook messages |

> **Extended Explanation: What is the Semaphore Pattern?**
>
> A semaphore is a classic concurrency control mechanism in operating systems, proposed by Dutch computer scientist Edsger Dijkstra in 1965. It maintains a counter representing the number of available resources.
>
> In oh-my-opencode's `ConcurrencyManager`:
> - `acquire()` = P operation (decrement semaphore by 1): Acquires an execution slot. If no slots are available, the caller is placed in a wait queue
> - `release()` = V operation (increment semaphore by 1): Releases a slot and wakes the next task in the wait queue
>
> This pattern ensures that the number of simultaneously running background Agents does not exceed the configured limit, preventing API rate limiting or resource exhaustion.
>
> Unlike traditional semaphores, oh-my-opencode's implementation uses JavaScript Promises to implement waiting/waking rather than OS-level thread blocking. This is because JavaScript's runtime is single-threaded, making Promise queues more natural than thread locks.

## Section Summary

The 20 Feature modules of oh-my-opencode cover the complete functional spectrum from background Agent management to tmux visualization. The most critical modules include:

1. **Background Agent System** (33 files): Complete sub-session creation, concurrency control, and result notification
2. **Boulder State**: Cross-session work plan state persistence
3. **tmux Sub-agent**: Visualizes background Agent work processes in tmux split panes
4. **Built-in Skills** (5): Injects domain expert knowledge
5. **Built-in Commands**: Predefined slash commands

These modules collaborate through well-defined interfaces -- for example, when a background Agent is created, the tmux manager is notified to allocate a pane; when a task completes, the notifier reports the result to the parent session.
