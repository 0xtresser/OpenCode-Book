# 15.2 Plugin Entry Point and Initialization

> **Model**: claude-opus-4-6 (anthropic/claude-opus-4-6)
> **Generation Date**: 2026-02-17

---

In the previous section, we provided an overview of oh-my-opencode's overall architecture and feature set. This section dives deep into its initialization process -- the complete chain from OpenCode calling the Plugin entry function, through configuration loading, Manager creation, tool registration, Hook creation, to final interface assembly.

## 15.2.1 `src/index.ts` -- Plugin Entry Point

oh-my-opencode's entry file is surprisingly concise. The entire file is only about 100 lines, yet it precisely orchestrates the entire initialization flow:

```typescript
// oh-my-opencode/src/index.ts
import type { Plugin } from "@opencode-ai/plugin"

const OhMyOpenCodePlugin: Plugin = async (ctx) => {
  log("[OhMyOpenCodePlugin] ENTRY - plugin loading", {
    directory: ctx.directory,
  })

  // Step 0: Basic environment preparation
  injectServerAuthIntoClient(ctx.client)
  startTmuxCheck()

  // Step 1: Load configuration
  const pluginConfig = loadPluginConfig(ctx.directory, ctx)
  const disabledHooks = new Set(pluginConfig.disabled_hooks ?? [])
  const isHookEnabled = (hookName: HookName): boolean => !disabledHooks.has(hookName)
  const safeHookEnabled = pluginConfig.experimental?.safe_hook_creation ?? true

  // Step 2: Create auxiliary state
  const firstMessageVariantGate = createFirstMessageVariantGate()
  const tmuxConfig = {
    enabled: pluginConfig.tmux?.enabled ?? false,
    layout: pluginConfig.tmux?.layout ?? "main-vertical",
    main_pane_size: pluginConfig.tmux?.main_pane_size ?? 60,
    // ...
  }
  const modelCacheState = createModelCacheState()

  // Step 3: Create Managers
  const managers = createManagers({
    ctx, pluginConfig, tmuxConfig, modelCacheState,
    backgroundNotificationHookEnabled: isHookEnabled("background-notification"),
  })

  // Step 4: Create tools (async)
  const toolsResult = await createTools({ ctx, pluginConfig, managers })

  // Step 5: Create Hooks
  const hooks = createHooks({
    ctx, pluginConfig, modelCacheState,
    backgroundManager: managers.backgroundManager,
    isHookEnabled, safeHookEnabled,
    mergedSkills: toolsResult.mergedSkills,
    availableSkills: toolsResult.availableSkills,
  })

  // Step 6: Assemble Plugin interface
  const pluginInterface = createPluginInterface({
    ctx, pluginConfig, firstMessageVariantGate,
    managers, hooks, tools: toolsResult.filteredTools,
  })

  // Step 7: Return the final interface (with compaction handling)
  return {
    ...pluginInterface,
    "experimental.session.compacting": async (_input, output) => {
      await hooks.compactionTodoPreserver?.capture(_input.sessionID)
      await hooks.claudeCodeHooks?.["experimental.session.compacting"]?.(_input, output)
      if (hooks.compactionContextInjector) {
        output.context.push(hooks.compactionContextInjector(_input.sessionID))
      }
    },
  }
}

export default OhMyOpenCodePlugin
```

### Three Main Initialization Steps

The core logic of the entry function is decomposed into three factory functions:

**`createManagers()`** -- Creates long-lived manager instances:

```typescript
// oh-my-opencode/src/create-managers.ts
export function createManagers(args): Managers {
  // TmuxSessionManager: Manages tmux pane creation, layout, and cleanup
  const tmuxSessionManager = new TmuxSessionManager(ctx, tmuxConfig)

  // BackgroundManager: Manages background Agent creation, polling, and concurrency control
  const backgroundManager = new BackgroundManager(ctx, pluginConfig.background_task, {
    tmuxConfig,
    onSubagentSessionCreated: async (event) => {
      // When a background sub-Agent creates a session, notify the tmux manager
      await tmuxSessionManager.onSessionCreated({ /* ... */ })
    },
    onShutdown: () => {
      // Clean up tmux resources on shutdown
      tmuxSessionManager.cleanup().catch(/* ... */)
    },
    enableParentSessionNotifications: backgroundNotificationHookEnabled,
  })

  // Initialize Toast notification manager
  initTaskToastManager(ctx.client)

  // SkillMcpManager: Manages the lifecycle of Skill embedded MCP services
  const skillMcpManager = new SkillMcpManager()

  // ConfigHandler: Handles runtime configuration queries
  const configHandler = createConfigHandler({
    ctx: { directory: ctx.directory, client: ctx.client },
    pluginConfig, modelCacheState,
  })

  return { tmuxSessionManager, backgroundManager, skillMcpManager, configHandler }
}
```

A noteworthy design here is that `BackgroundManager` receives an `onSubagentSessionCreated` callback. This implements **loose coupling** between the background Agent system and the tmux visualization system -- when a background sub-Agent is created, the tmux manager automatically allocates a new terminal pane for it, allowing the user to observe the sub-Agent's work status in real time.

**`createTools()`** -- Registers all custom tools:

```typescript
// oh-my-opencode/src/create-tools.ts
export async function createTools(args): Promise<CreateToolsResult> {
  // Load Skill context (user-installed Skill files)
  const skillContext = await createSkillContext({
    directory: ctx.directory,
    pluginConfig,
  })

  // Create Category list (used for the task tool's category parameter)
  const availableCategories = createAvailableCategories(pluginConfig)

  // Register all tools in the tool registry
  const { filteredTools, taskSystemEnabled } = createToolRegistry({
    ctx, pluginConfig, managers,
    skillContext, availableCategories,
  })

  return {
    filteredTools,
    mergedSkills: skillContext.mergedSkills,
    availableSkills: skillContext.availableSkills,
    availableCategories,
    browserProvider: skillContext.browserProvider,
    disabledSkills: skillContext.disabledSkills,
    taskSystemEnabled,
  }
}
```

Note that `createTools` is the only **asynchronous** step in the entire initialization chain (preceded by `await`). This is because Skill loading requires reading `.md` files from the filesystem, which involves I/O operations.

**`createHooks()`** -- Creates all behavioral hooks:

```typescript
// oh-my-opencode/src/create-hooks.ts
export function createHooks(args) {
  // Core hooks: context monitoring, error recovery, notifications, etc.
  const core = createCoreHooks({
    ctx, pluginConfig, modelCacheState,
    isHookEnabled, safeHookEnabled,
  })

  // Continuation hooks: Ralph Loop, Todo enforcement, Start Work, etc.
  const continuation = createContinuationHooks({
    ctx, pluginConfig, isHookEnabled, safeHookEnabled,
    backgroundManager, sessionRecovery: core.sessionRecovery,
  })

  // Skill hooks: Category-Skill reminders, Agent usage reminders, etc.
  const skill = createSkillHooks({
    ctx, isHookEnabled, safeHookEnabled,
    mergedSkills, availableSkills,
  })

  return { ...core, ...continuation, ...skill }
}
```

Hooks are further divided into three sub-factory groups: `createCoreHooks()`, `createContinuationHooks()`, and `createSkillHooks()`. This grouping reduces the complexity of individual files while allowing each group of hooks to share intra-group dependencies.

### Interface Assembly

Finally, `createPluginInterface()` maps all prepared components to the OpenCode Plugin interface:

```typescript
// oh-my-opencode/src/plugin-interface.ts
export function createPluginInterface(args): PluginInterface {
  return {
    tool: tools,                                    // Custom tools

    "chat.params": createChatParamsHandler({...}),  // Request parameter injection
    "chat.message": createChatMessageHandler({...}),// Message preprocessing
    "experimental.chat.messages.transform":         // Message list transformation
      createMessagesTransformHandler({...}),

    config: managers.configHandler,                 // Configuration handling

    event: createEventHandler({...}),               // Event handling
    "tool.execute.before": createToolExecuteBeforeHandler({...}), // Pre-tool execution
    "tool.execute.after": createToolExecuteAfterHandler({...}),   // Post-tool execution
  }
}
```

Each interface field is created through a dedicated Handler factory function, achieving separation of concerns.

## 15.2.2 Configuration Loading (`plugin-config.ts`)

oh-my-opencode has a flexible two-tier configuration system that supports merging **user-level** and **project-level** configurations.

### Configuration File Discovery

```typescript
// oh-my-opencode/src/plugin-config.ts
export function loadPluginConfig(directory: string, ctx: unknown): OhMyOpenCodeConfig {
  // User-level config path: ~/.config/opencode/oh-my-opencode.json[c]
  const configDir = getOpenCodeConfigDir({ binary: "opencode" })
  const userBasePath = path.join(configDir, "oh-my-opencode")
  const userDetected = detectConfigFile(userBasePath)

  // Project-level config path: <project>/.opencode/oh-my-opencode.json[c]
  const projectBasePath = path.join(directory, ".opencode", "oh-my-opencode")
  const projectDetected = detectConfigFile(projectBasePath)

  // Load user-level config as the base first
  let config = loadConfigFromPath(userConfigPath, ctx) ?? {}

  // Then override with project-level config
  const projectConfig = loadConfigFromPath(projectConfigPath, ctx)
  if (projectConfig) {
    config = mergeConfigs(config, projectConfig)
  }

  return config
}
```

Configuration discovery follows a clear priority chain:

```
Project-level .opencode/oh-my-opencode.jsonc  (highest priority)
  ↓ merge
Project-level .opencode/oh-my-opencode.json
  ↓ merge
User-level ~/.config/opencode/oh-my-opencode.jsonc
  ↓ merge
User-level ~/.config/opencode/oh-my-opencode.json
  ↓ merge
Default values (defined by Zod Schema)         (lowest priority)
```

### JSONC Support

oh-my-opencode uses the `jsonc-parser` library to support the **JSONC (JSON with Comments)** format:

```typescript
// oh-my-opencode/src/shared/jsonc-parser.ts
import { parse, ParseError, printParseErrorCode } from "jsonc-parser"

export function parseJsonc<T = unknown>(content: string): T {
  const errors: ParseError[] = []
  const result = parse(content, errors, {
    allowTrailingComma: true,    // Allow trailing commas
    disallowComments: false,     // Allow comments
  }) as T

  if (errors.length > 0) {
    throw new SyntaxError(`JSONC parse error: ${errorMessages}`)
  }
  return result
}
```

> **Extended Explanation: What is JSONC?**
>
> Standard JSON does not allow comments or trailing commas. This is a significant inconvenience for configuration files -- users cannot write explanatory text next to configuration items. JSONC (JSON with Comments) is an extended format popularized by Microsoft through VS Code, adding two features on top of standard JSON:
>
> 1. **Line comments**: `// this is a comment`
> 2. **Block comments**: `/* this is also a comment */`
> 3. **Trailing commas**: `{ "a": 1, "b": 2, }` -- the trailing comma won't cause an error
>
> Many tools support JSONC, including VS Code's `settings.json`, TypeScript's `tsconfig.json`, and others. oh-my-opencode provides native JSONC support through the `jsonc-parser` library.

### Partial Configuration Fault-Tolerant Parsing

A highlight of oh-my-opencode is its **partial configuration fault tolerance** (Partial Config Parsing). When a field in the configuration file is invalid, it does not cause the entire configuration to fail. Instead, the invalid portion is skipped while retaining the valid configuration:

```typescript
// oh-my-opencode/src/plugin-config.ts
export function parseConfigPartially(
  rawConfig: Record<string, unknown>
): OhMyOpenCodeConfig | null {
  // First, attempt full parsing
  const fullResult = OhMyOpenCodeConfigSchema.safeParse(rawConfig)
  if (fullResult.success) {
    return fullResult.data
  }

  // Full parsing failed → try field by field
  const partialConfig: Record<string, unknown> = {}
  const invalidSections: string[] = []

  for (const key of Object.keys(rawConfig)) {
    // Validate each top-level field individually
    const sectionResult = OhMyOpenCodeConfigSchema.safeParse({ [key]: rawConfig[key] })
    if (sectionResult.success) {
      const parsed = sectionResult.data as Record<string, unknown>
      if (parsed[key] !== undefined) {
        partialConfig[key] = parsed[key]
      }
    } else {
      // Record the failed field but don't abort
      invalidSections.push(`${key}: ${sectionErrors}`)
    }
  }

  if (invalidSections.length > 0) {
    log("Partial config loaded — invalid sections skipped:", invalidSections)
  }

  return partialConfig as OhMyOpenCodeConfig
}
```

The core idea behind this design is: an error in the `agents` field of the configuration should not prevent `hooks` and `tools` from working correctly. By validating field by field, oh-my-opencode retains as much valid configuration as possible while informing the user through logs about which sections were skipped.

### Configuration Merge Strategy

The merging of two-tier configurations is not a simple override. Instead, different strategies are applied based on field types:

```typescript
// oh-my-opencode/src/plugin-config.ts
export function mergeConfigs(
  base: OhMyOpenCodeConfig,
  override: OhMyOpenCodeConfig
): OhMyOpenCodeConfig {
  return {
    ...base,
    ...override,
    // Object-type fields: deep merge
    agents: deepMerge(base.agents, override.agents),
    categories: deepMerge(base.categories, override.categories),
    claude_code: deepMerge(base.claude_code, override.claude_code),

    // Array-type fields: deduplicated union
    disabled_agents: [
      ...new Set([
        ...(base.disabled_agents ?? []),
        ...(override.disabled_agents ?? []),
      ]),
    ],
    disabled_hooks: [
      ...new Set([
        ...(base.disabled_hooks ?? []),
        ...(override.disabled_hooks ?? []),
      ]),
    ],
    // disabled_mcps, disabled_commands, disabled_skills follow the same pattern...
  }
}
```

The merge strategy can be summarized as:
- **Scalar fields** (`string`, `boolean`, `number`): Project config directly overrides user config
- **Object fields** (`agents`, `categories`): Deep merge, where specific fields in the project config override same-named fields in the user config
- **Array fields** (`disabled_*`): The two layers' arrays are **unioned** (with deduplication), meaning if either layer disables an item, the item is disabled in the final result

### Configuration Migration

oh-my-opencode also implements an **automatic configuration migration** mechanism. As versions evolve, the names or structures of certain configuration items may change. The migration system automatically converts old formats to new formats during configuration loading:

```typescript
// Automatic migration during config loading
const rawConfig = parseJsonc<Record<string, unknown>>(content)
migrateConfigFile(configPath, rawConfig)
```

The migration system covers four areas:
- **Agent name migration**: Mapping old Agent names to new names
- **Hook name migration**: Mapping old Hook names to new names
- **Model version migration**: Automatically upgrading `claude-3.5-sonnet` to `claude-4-sonnet`, for example
- **Agent config to Category migration**: Migrating the legacy direct `model` configuration to the new indirect `category` configuration

## 15.2.3 `OhMyOpenCodeConfig` Configuration Schema

oh-my-opencode's configuration is defined using Zod Schemas, ensuring type safety and runtime validation. The main Schema is defined in `config/schema/oh-my-opencode-config.ts`:

```typescript
// oh-my-opencode/src/config/schema/oh-my-opencode-config.ts
export const OhMyOpenCodeConfigSchema = z.object({
  $schema: z.string().optional(),

  // === Feature toggles ===
  new_task_system_enabled: z.boolean().optional(),
  default_run_agent: z.string().optional(),

  // === Disable lists ===
  disabled_mcps: z.array(AnyMcpNameSchema).optional(),
  disabled_agents: z.array(BuiltinAgentNameSchema).optional(),
  disabled_skills: z.array(BuiltinSkillNameSchema).optional(),
  disabled_hooks: z.array(HookNameSchema).optional(),
  disabled_commands: z.array(BuiltinCommandNameSchema).optional(),
  disabled_tools: z.array(z.string()).optional(),

  // === Agent configuration ===
  agents: AgentOverridesSchema.optional(),
  categories: CategoriesConfigSchema.optional(),
  sisyphus_agent: SisyphusAgentConfigSchema.optional(),
  sisyphus: SisyphusConfigSchema.optional(),

  // === Feature module configuration ===
  claude_code: ClaudeCodeConfigSchema.optional(),
  comment_checker: CommentCheckerConfigSchema.optional(),
  skills: SkillsConfigSchema.optional(),
  ralph_loop: RalphLoopConfigSchema.optional(),
  background_task: BackgroundTaskConfigSchema.optional(),
  notification: NotificationConfigSchema.optional(),
  babysitting: BabysittingConfigSchema.optional(),
  git_master: GitMasterConfigSchema.optional(),
  browser_automation_engine: BrowserAutomationConfigSchema.optional(),
  websearch: WebsearchConfigSchema.optional(),
  tmux: TmuxConfigSchema.optional(),

  // === Experimental features ===
  experimental: ExperimentalConfigSchema.optional(),
  auto_update: z.boolean().optional(),

  // === Internal state ===
  _migrations: z.array(z.string()).optional(),
})
```

### Agent Override Configuration

Each Agent's behavior can be fine-tuned through configuration overrides:

```typescript
// oh-my-opencode/src/config/schema/agent-overrides.ts
export const AgentOverrideConfigSchema = z.object({
  category: z.string().optional(),         // Inherited Category
  variant: z.string().optional(),          // Agent variant
  skills: z.array(z.string()).optional(),  // Injected Skill list
  temperature: z.number().min(0).max(2).optional(),
  top_p: z.number().min(0).max(1).optional(),
  prompt: z.string().optional(),           // Fully replace Prompt
  prompt_append: z.string().optional(),    // Append to Prompt
  tools: z.record(z.string(), z.boolean()).optional(),  // Tool toggles
  disable: z.boolean().optional(),         // Disable the entire Agent
  description: z.string().optional(),
  mode: z.enum(["subagent", "primary", "all"]).optional(),
  color: z.string().regex(/^#[0-9A-Fa-f]{6}$/).optional(),
  maxTokens: z.number().optional(),
  thinking: z.object({                     // Extended thinking (Anthropic)
    type: z.enum(["enabled", "disabled"]),
    budgetTokens: z.number().optional(),
  }).optional(),
  reasoningEffort: z.enum(["low", "medium", "high", "xhigh"]).optional(),
  textVerbosity: z.enum(["low", "medium", "high"]).optional(),
  providerOptions: z.record(z.string(), z.unknown()).optional(),
})

// List of overridable Agents
export const AgentOverridesSchema = z.object({
  build: AgentOverrideConfigSchema.optional(),
  plan: AgentOverrideConfigSchema.optional(),
  sisyphus: AgentOverrideConfigSchema.optional(),
  hephaestus: AgentOverrideConfigSchema.optional(),
  "sisyphus-junior": AgentOverrideConfigSchema.optional(),
  prometheus: AgentOverrideConfigSchema.optional(),
  metis: AgentOverrideConfigSchema.optional(),
  momus: AgentOverrideConfigSchema.optional(),
  oracle: AgentOverrideConfigSchema.optional(),
  librarian: AgentOverrideConfigSchema.optional(),
  explore: AgentOverrideConfigSchema.optional(),
  "multimodal-looker": AgentOverrideConfigSchema.optional(),
  atlas: AgentOverrideConfigSchema.optional(),
})
```

A typical Agent override configuration example:

```jsonc
// .opencode/oh-my-opencode.jsonc
{
  "agents": {
    "oracle": {
      "category": "ultrabrain",        // Use the ultrabrain category's model
      "temperature": 0.3,              // Lower randomness
      "prompt_append": "Always respond in Chinese.",  // Append instruction
      "thinking": {
        "type": "enabled",
        "budgetTokens": 10000          // Allow 10K tokens for deep thinking
      }
    },
    "explore": {
      "category": "quick",             // Use the quick category (cheaper model)
      "tools": {
        "bash": false                  // Prevent Explore Agent from using Bash
      }
    }
  }
}
```

### Background Task Configuration

Background Agent concurrency control is one of oh-my-opencode's key configurations:

```typescript
// oh-my-opencode/src/config/schema/background-task.ts
export const BackgroundTaskConfigSchema = z.object({
  // Default concurrency
  defaultConcurrency: z.number().min(1).optional(),
  // Per-provider concurrency limits
  providerConcurrency: z.record(z.string(), z.number().min(0)).optional(),
  // Per-model concurrency limits
  modelConcurrency: z.record(z.string(), z.number().min(0)).optional(),
  // Idle timeout (milliseconds), stale tasks will be interrupted (default 3 minutes)
  staleTimeoutMs: z.number().min(60000).optional(),
  // Timeout for no progress updates received (default 10 minutes)
  messageStalenessTimeoutMs: z.number().min(60000).optional(),
})
```

This allows users to precisely control concurrency based on their API quotas:

```jsonc
{
  "background_task": {
    "defaultConcurrency": 3,
    "providerConcurrency": {
      "anthropic": 2,    // Max 2 concurrent requests for Anthropic API
      "openai": 5        // Max 5 concurrent requests for OpenAI API
    },
    "staleTimeoutMs": 300000  // 5 minutes of inactivity triggers timeout
  }
}
```

### Built-in Agent and Skill Enum Types

Configuration type safety extends beyond structure to enumeration values. oh-my-opencode defines strict enum Schemas for all built-in Agents and Skills:

```typescript
// oh-my-opencode/src/config/schema/agent-names.ts
export const BuiltinAgentNameSchema = z.enum([
  "sisyphus", "hephaestus", "prometheus", "oracle",
  "librarian", "explore", "multimodal-looker",
  "metis", "momus", "atlas",
])

export const BuiltinSkillNameSchema = z.enum([
  "playwright", "agent-browser", "dev-browser",
  "frontend-ui-ux", "git-master",
])
```

This means that if a user writes a nonexistent Agent name in `disabled_agents`, Zod validation will report an error during configuration loading (but thanks to partial fault-tolerant parsing, this won't cause the entire configuration to fail).

### Hook Name Enums

All 49 hooks that can be disabled through configuration have enum definitions:

```typescript
// oh-my-opencode/src/config/schema/hooks.ts
export const HookNameSchema = z.enum([
  "todo-continuation-enforcer",
  "context-window-monitor",
  "session-recovery",
  "session-notification",
  "comment-checker",
  "tool-output-truncator",
  "directory-agents-injector",
  "preemptive-compaction",
  "rules-injector",
  "ralph-loop",
  "edit-error-recovery",
  "unstable-agent-babysitter",
  // ... 49 total
])
```

> **Extended Explanation: The Schema-First Design Pattern**
>
> oh-my-opencode's configuration system adopts the "Schema-first" design pattern: first define the complete structure and constraints of the configuration using Zod, then generate types and validation logic based on the Schema.
>
> This pattern has several key advantages:
>
> 1. **Type safety**: `z.infer<typeof Schema>` automatically generates TypeScript types, eliminating the need for hand-written `interface` definitions
> 2. **Runtime validation**: The Schema is not just a type definition but also a runtime validator. User configuration files are validated during loading
> 3. **Self-documenting**: The Schema definition itself serves as configuration documentation -- it precisely describes each field's type, constraints, and default values
> 4. **JSON Schema generation**: Zod Schemas can be automatically converted to standard JSON Schema (oh-my-opencode does this via a `build:schema` script), enabling IDE autocompletion and validation
>
> This contrasts with the traditional "type-first" pattern (writing a TypeScript `interface` first, then hand-coding validation logic). The Schema-first pattern eliminates the risk of inconsistencies between type definitions and validation logic.

### Plugin-Level Global State

oh-my-opencode maintains a small amount of plugin-level global state:

```typescript
// oh-my-opencode/src/plugin-state.ts
export interface ModelCacheState {
  modelContextLimitsCache: Map<string, number>  // Model context window size cache
  anthropicContext1MEnabled: boolean             // Whether Anthropic 1M token context is enabled
}

export function createModelCacheState(): ModelCacheState {
  return {
    modelContextLimitsCache: new Map<string, number>(),
    anthropicContext1MEnabled: false,
  }
}
```

This state is shared across multiple hooks. For example, the `context-window-monitor` hook needs to know the current model's context window size to determine whether compaction should be triggered, and the `preemptive-compaction` hook also needs the same information to decide when to preemptively compact context. By sharing `ModelCacheState`, redundant model information queries are avoided.

## Section Summary

oh-my-opencode's initialization flow follows a **staged, chain-dependent** pattern:

1. **Environment preparation**: Inject authentication, detect tmux
2. **Configuration loading**: Two-tier config (user-level + project-level) merging, with JSONC and partial fault tolerance support
3. **Manager creation**: tmux, background Agent, Skill MCP, configuration handler
4. **Tool registration** (async): Load Skill context, create Categories, register 15 tools
5. **Hook creation**: Core hooks + Continuation hooks + Skill hooks
6. **Interface assembly**: Map all capabilities to the OpenCode Plugin interface

Three design highlights of the configuration system are: **partial fault-tolerant parsing** (a single field error doesn't affect the whole), **intelligent merge strategy** (deep merge for objects, union for arrays, override for scalars), and **Schema-first design** (Zod serves as both type definition and runtime validator).
