# 15.7 Plugin Interface Implementation

> **Model**: claude-opus-4-6 (anthropic/claude-opus-4-6)
> **Generation Date**: 2026-02-17

---

The `plugin/` directory is oh-my-opencode's **interface layer** -- it "translates" internal capabilities such as Agents, tools, and Hooks into the OpenCode Plugin interface. This section analyzes each interface implementation.

## 15.7.1 `plugin/chat-params.ts`: Anthropic Effort Level Injection

The `chat.params` Hook modifies request parameters before the LLM request is sent. oh-my-opencode uses it to inject Anthropic's effort level:

```typescript
// oh-my-opencode/src/plugin/chat-params.ts
export function createChatParamsHandler(args: {
  anthropicEffort: { "chat.params"?: (input, output) => Promise<void> } | null
}): (input, output) => Promise<void> {
  return async (input, output) => {
    const normalizedInput = buildChatParamsInput(input)
    if (!normalizedInput) return
    if (!isChatParamsOutput(output)) return

    // Delegate to the anthropicEffort Hook
    await args.anthropicEffort?.["chat.params"]?.(normalizedInput, output)
  }
}
```

The `ChatParamsOutput` structure allows modification of temperature, topP, topK, and arbitrary provider-specific options:

```typescript
type ChatParamsOutput = {
  temperature?: number
  topP?: number
  topK?: number
  options: Record<string, unknown>  // Provider-specific extensions
}
```

## 15.7.2 `plugin/chat-message.ts`: Message Preprocessing

The `chat.message` Hook preprocesses user messages before they are sent to the LLM, making it one of oh-my-opencode's most complex interface implementations:

```typescript
// oh-my-opencode/src/plugin/chat-message.ts
export function createChatMessageHandler(args) {
  return async (input, output) => {
    // 1. Record Session-Agent mapping
    if (input.agent) {
      setSessionAgent(input.sessionID, input.agent)
    }

    // 2. First message variant injection (variant gate)
    if (firstMessageVariantGate.shouldOverride(input.sessionID)) {
      const variant = resolveVariantForModel(input.model) ??
                      resolveAgentVariant(pluginConfig.agents, input.agent)
      if (variant) {
        applyAgentVariant(output.message, variant)
        firstMessageVariantGate.markApplied(input.sessionID)
      }
    }

    // 3. Context injection Hook chain
    await hooks.directoryAgentsInjector?.inject(input, output)
    await hooks.directoryReadmeInjector?.inject(input, output)
    await hooks.rulesInjector?.inject(input, output)

    // 4. Keyword detection (e.g., "ultrawork")
    await hooks.keywordDetector?.detect(input, output)

    // 5. Start Work Hook
    await hooks.startWork?.["chat.message"]?.(input, output)
  }
}
```

This Handler executes a series of ordered operations:

1. **Session-Agent mapping recording**: Records which session uses which Agent, available for subsequent Hook queries
2. **First message variant injection**: Applies an Agent variant to the session's first message, enabling fine-tuning of model behavior
3. **Context injection**: Injects the contents of AGENTS.md, README.md, and rule files into the message
4. **Keyword detection**: Scans user messages for keywords (e.g., "ultrawork") and triggers corresponding automation flows
5. **Start Work Hook**: If a work launch command is detected, triggers the start-work flow

## 15.7.3 `plugin/messages-transform.ts`: Message List Transformation

`experimental.chat.messages.transform` is an experimental interface that allows transformation of the entire message list before it is sent to the LLM. oh-my-opencode uses it to implement thinking block validation and message format normalization.

## 15.7.4 `plugin/event.ts`: Event Handling

The `event` Handler is oh-my-opencode's event dispatch center, routing OpenCode events to various Hooks:

```typescript
// oh-my-opencode/src/plugin/event.ts
export function createEventHandler(args) {
  return async (input: { event: { type: string; properties?: unknown } }) => {
    const event = input.event

    // Dispatch to each Hook's event handler
    await hooks.preemptiveCompaction?.event(input)
    await hooks.ralphLoop?.event(input)
    await hooks.sessionNotification?.event(input)
    await hooks.todoContinuation?.handler.event(input)
    await hooks.contextWindowMonitor?.event(input)

    // Special handling for session lifecycle events
    if (event.type === "session.created") {
      firstMessageVariantGate.markSessionCreated(event.properties?.info)
    }
    if (event.type === "session.deleted") {
      // Clean up various session states
    }
  }
}
```

## 15.7.5 `plugin/tool-execute-before.ts`: Pre-Tool-Execution Interception

The `tool.execute.before` Hook is called before a tool executes. It can modify the tool's input parameters or cancel execution entirely.

oh-my-opencode uses it to implement:
- **Hashline Read enhancement**: Adds markers before Read tool execution so that output includes line number hashes
- **Write protection**: Checks whether an existing file is about to be overwritten and issues a warning
- **Claude Code Hook compatibility**: Triggers Claude Code-format PreToolUse Hooks

## 15.7.6 `plugin/tool-execute-after.ts`: Post-Tool-Execution Processing

The `tool.execute.after` Hook is called after a tool finishes executing. It can modify the tool's output or trigger side effects.

oh-my-opencode uses it to implement:
- **Tool output truncation**: Prevents excessively long output from consuming too many tokens
- **Edit error recovery**: Detects Edit tool errors and injects recovery instructions
- **Preemptive compaction**: Checks token usage and triggers compaction
- **Context window monitoring**: Issues context usage warnings
- **Comment checking**: Detects excessive comments in AI-generated code

## 15.7.7 `plugin/session-agent-resolver.ts`: Session-Agent Mapping

The Session Agent Resolver infers the currently active Agent from a session's message history:

```typescript
// oh-my-opencode/src/plugin/session-agent-resolver.ts
export async function resolveSessionAgent(client, sessionId): Promise<string | undefined> {
  const messagesResp = await client.session.messages({ path: { id: sessionId } })
  const messages = normalizeSDKResponse(messagesResp, [])

  // Find the first message containing agent information from the message list
  for (const msg of messages) {
    if (msg.info?.agent) {
      return msg.info.agent
    }
  }
  return undefined
}
```

This function is used in multiple scenarios -- for example, when a background task completes, it needs to know which Agent the parent session is using so that notifications are sent to the correct Agent.

## 15.7.8 `plugin/available-categories.ts`: Category Definitions

`createAvailableCategories()` builds the list of available Categories from the configuration, for use by the `task` tool's `category` parameter.

## 15.7.9 `plugin/tool-registry.ts`: Tool Registry

`createToolRegistry()` is the core of tool registration. It aggregates all custom tools, applies the disabled list filter, and returns the final tool table:

```typescript
export function createToolRegistry(args): { filteredTools, taskSystemEnabled } {
  // 1. Collect all tools
  const allTools = {
    ...builtinTools,                    // LSP tools
    ...createAstGrepTools(ctx),         // AST-Grep
    ...createBackgroundTools(mgr, cli), // Background tasks
    ...createGrepTools(ctx),            // Grep
    ...createGlobTools(ctx),            // Glob
    // ... more tools
  }

  // 2. Apply disabled list
  const disabledTools = new Set(pluginConfig.disabled_tools ?? [])
  const filteredTools = Object.fromEntries(
    Object.entries(allTools).filter(([name]) => !disabledTools.has(name))
  )

  return { filteredTools, taskSystemEnabled }
}
```

## Section Summary

oh-my-opencode's Plugin Interface layer maps the capabilities of its internal 53 Hooks, 15 tools, and 11 Agents onto the OpenCode Plugin interface through 9 specialized Handler functions. Each Handler is a thin adaptation layer -- its primary job is to normalize input/output, dispatch events to internal Hooks, and handle edge cases.

This design ensures that oh-my-opencode's internal architecture is completely independent of OpenCode's Plugin interface design -- even if OpenCode's Plugin interface changes, only these Handler functions need to be modified, without touching the internal Agent, Hook, or tool logic.
