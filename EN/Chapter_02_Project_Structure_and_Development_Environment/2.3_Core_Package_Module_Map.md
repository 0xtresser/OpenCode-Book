# 2.3 Core Package `packages/opencode/src/` Module Map

> **Model**: claude-opus-4-6 (anthropic/claude-opus-4-6)
> **Generation Date**: 2025-02-17

---

`packages/opencode/src/` is the brain and heart of the entire OpenCode system. This directory contains 37 modules (subdirectories), each responsible for a distinct area of functionality. This section introduces each of them and analyzes the dependency relationships between modules.

## 2.3.1 Overview of All 37 Module Directories

Grouped by functionality, these 37 modules can be divided into six major categories:

### Core Business Modules

| Module | Directory | Key Files | Responsibility |
|--------|-----------|-----------|----------------|
| **Session** | `session/` | `index.ts`, `processor.ts`, `llm.ts`, `compaction.ts` | Session management. OpenCode's core abstraction -- manages conversation lifecycle, message processing, and the Agentic Loop |
| **Tool** | `tool/` | `tool.ts`, `registry.ts`, 20+ tool files | Tool system. Defines all tools available to the Agent (read/write files, execute commands, etc.) |
| **Agent** | `agent/` | `agent.ts`, `prompt/*.txt` | Agent definitions. Configures AI behavior modes, permissions, and prompts |
| **Provider** | `provider/` | `provider.ts`, `transform.ts`, `models.ts` | Multi-model adaptation. Unified integration with 20+ LLM Providers |
| **MCP** | `mcp/` | `index.ts`, `auth.ts`, `oauth-*.ts` | Model Context Protocol client. Connects to the external tool ecosystem |
| **Permission** | `permission/` | `next.ts`, `index.ts`, `arity.ts` | Permission control. Manages the behavioral boundaries of the Agent |

### Infrastructure Modules

| Module | Directory | Key Files | Responsibility |
|--------|-----------|-----------|----------------|
| **Config** | `config/` | `config.ts`, `markdown.ts` | Configuration system. Layered loading and merging of configuration |
| **Storage** | `storage/` | `storage.ts` | Local persistence. File storage for Session data and message history |
| **Bus** | `bus/` | `index.ts`, `bus-event.ts`, `global.ts` | Event bus. Decoupled inter-module communication |
| **Scheduler** | `scheduler/` | `index.ts` | Scheduled tasks. Such as Snapshot cleanup |
| **Global** | `global/` | `index.ts` | Global path management. XDG-compliant directory structure |
| **Project** | `project/` | `instance.ts`, `project.ts`, `state.ts`, `vcs.ts` | Project management. Multi-project instance isolation |
| **Auth** | `auth/` | `index.ts` | Authentication. API Key and OAuth credential management |

### User Interface Modules

| Module | Directory | Key Files | Responsibility |
|--------|-----------|-----------|----------------|
| **CLI** | `cli/` | `bootstrap.ts`, `cmd/*.ts`, `cmd/tui/` | Command-line interface. Entry point, subcommands, TUI rendering |
| **Server** | `server/` | `server.ts`, `routes/*.ts`, `event.ts` | HTTP service. API routes and SSE push |

### File and Version Control Modules

| Module | Directory | Key Files | Responsibility |
|--------|-----------|-----------|----------------|
| **Snapshot** | `snapshot/` | `index.ts` | Git snapshots. A safety net for file changes |
| **File** | `file/` | `index.ts`, `ignore.ts`, `ripgrep.ts`, `watcher.ts` | File operations. Search, watching, .gitignore parsing |
| **Patch** | `patch/` | `index.ts` | Diff patches. Generating and applying code changes |
| **Worktree** | `worktree/` | `index.ts` | Git Worktree management |

### Extensibility Modules

| Module | Directory | Key Files | Responsibility |
|--------|-----------|-----------|----------------|
| **Plugin** | `plugin/` | `index.ts`, `codex.ts`, `copilot.ts` | Plugin loading. Dynamic loading and management of Plugins |
| **Skill** | `skill/` | `index.ts`, `skill.ts`, `discovery.ts` | Skill management. Discovery and loading of Markdown Skill files |
| **Command** | `command/` | `index.ts`, `template/` | Custom commands. The Slash Command system |
| **ACP** | `acp/` | `agent.ts`, `session.ts`, `types.ts` | Agent Client Protocol. IDE integration protocol |

### Utility Modules

| Module | Directory | Key Files | Responsibility |
|--------|-----------|-----------|----------------|
| **ID** | `id/` | `id.ts` | Identifier generation. Ordered ULID generation |
| **Flag** | `flag/` | `flag.ts` | Environment variables. Feature flags and configuration overrides |
| **Env** | `env/` | `index.ts` | Environment detection |
| **Format** | `format/` | `formatter.ts`, `index.ts` | Formatting utilities |
| **Shell** | `shell/` | `shell.ts` | Shell environment. Detection and configuration of the user's shell |
| **PTY** | `pty/` | `index.ts` | Pseudo-terminal. Support for interactive terminal operations |
| **IDE** | `ide/` | `index.ts` | IDE detection. Identifies the user's development environment |
| **Installation** | `installation/` | `index.ts` | Installation information. Version and update detection |
| **Share** | `share/` | `share.ts`, `share-next.ts` | Session sharing. Generates shareable session links |
| **Question** | `question/` | `index.ts` | Interactive questioning. Allows the Agent to prompt the user with questions |
| **Bun** | `bun/` | -- | Bun runtime helpers. Dynamic npm package installation, etc. |
| **Util** | `util/` | Multiple utility files | Common utility functions. Logging, filesystem, token counting, etc. |

## 2.3.2 Inter-Module Dependency Graph (DAG Analysis)

Understanding the dependency relationships between modules is key to reading the source code. The following is a dependency graph of the core modules (arrows indicate "depends on"):

```
┌──────────────────────────────────────────────────────┐
│                      CLI Layer                        │
│  cli/ ─────► server/ ─────► session/ ─────► tool/    │
│                                │                │     │
│                                ▼                ▼     │
│                            agent/           registry/ │
│                                │                │     │
│                                ▼                ▼     │
│                           provider/          mcp/     │
└──────────────────────────────────────────────────────┘
                                │
                                ▼
┌──────────────────────────────────────────────────────┐
│                Infrastructure Layer                   │
│  config/   bus/   storage/   permission/              │
│     │       │        │            │                   │
│     └───────┴────────┴────────────┘                   │
│                      │                                │
│                      ▼                                │
│               project/instance                        │
│                      │                                │
│                      ▼                                │
│               global/  util/  id/                     │
└──────────────────────────────────────────────────────┘
```

**Key dependency paths**:

1. **CLI -> Server -> Session -> Tool**: This is the main request processing path. User input in the CLI -> Server receives it -> Session manages the conversation -> Tool executes operations.
2. **Session -> Agent -> Provider**: Session needs to know which Agent to use, and the Agent needs to know which model Provider to use.
3. **Nearly all modules -> `project/instance`**: `Instance` provides instance-level state management capabilities and serves as the state foundation of the entire system.
4. **Nearly all modules -> `config/`, `bus/`**: Configuration and the event bus are cross-cutting concerns.

## 2.3.3 The `Instance` State Management Pattern in Detail

In the OpenCode source code, you will frequently encounter the following code pattern:

```typescript
const state = Instance.state(async () => {
  // Initialize state
  return { /* ... */ }
})
```

This is one of OpenCode's most fundamental design patterns -- the **Instance State Pattern**. Let's understand it through the source code.

**Definition of `Instance`** (`project/instance.ts`):

```typescript
export const Instance = {
  async provide<R>(input: {
    directory: string
    init?: () => Promise<any>
    fn: () => R
  }): Promise<R> {
    // Create or retrieve an instance context for the specified directory
    let existing = cache.get(input.directory)
    if (!existing) {
      existing = iife(async () => {
        const { project, sandbox } = await Project.fromDirectory(input.directory)
        return { directory: input.directory, worktree: sandbox, project }
      })
      cache.set(input.directory, existing)
    }
    const ctx = await existing
    return context.provide(ctx, async () => input.fn())
  },

  get directory() { return context.use().directory },
  get worktree() { return context.use().worktree },
  get project() { return context.use().project },

  state<S>(init: () => S, dispose?: (state: Awaited<S>) => Promise<void>): () => S {
    return State.create(() => Instance.directory, init, dispose)
  },
}
```

**Core ideas**:

1. **Each project directory is an isolated instance**. When OpenCode manages multiple projects, each project has its own independent state space.
2. **`Instance.state()` is a state factory**. It returns a function that, when called, returns the state corresponding to the current `Instance.directory`. If the state does not exist, it is created via the `init` function.
3. **State is lazily initialized**. The initialization logic is only executed on first access.
4. **State supports disposal**. When an instance is released, the `dispose` callback cleans up resources.

> **Extended Explanation: Singleton Pattern vs. Context Pattern**
>
> The traditional Singleton Pattern ensures that a class has only one instance. However, in OpenCode, what is needed is a **"per-project-directory sharded multi-instance singleton"** -- the same module has different state instances under different project directories.
>
> This is achieved through the `Context` utility class, which is essentially similar to React's Context API or Java's ThreadLocal -- carrying implicit state information within a specific execution context, avoiding the need to pass parameters through every function call in the chain.
>
> This pattern is extremely prevalent in OpenCode. Understanding it is a prerequisite for reading the source code.

**A practical example** -- how `Bus` (the event bus) uses Instance State:

```typescript
export namespace Bus {
  // Each project instance has its own independent event subscription list
  const state = Instance.state(
    () => {
      const subscriptions = new Map<any, Subscription[]>()
      return { subscriptions }
    },
    async (entry) => {
      // On instance disposal, trigger notifications and clean up
      const wildcard = entry.subscriptions.get("*")
      if (wildcard) {
        for (const sub of [...wildcard]) {
          sub({ type: "server.instance.disposed", ... })
        }
      }
    },
  )
}
```

**The `Global` Module** -- global path management:

Unlike `Instance`'s instance-level state, `Global` manages globally shared path information:

```typescript
export namespace Global {
  export const Path = {
    get home() { return process.env.OPENCODE_TEST_HOME || os.homedir() },
    data,        // ~/.local/share/opencode
    bin,         // ~/.local/share/opencode/bin
    log,         // ~/.local/share/opencode/log
    cache,       // ~/.cache/opencode
    config,      // ~/.config/opencode
    state,       // ~/.local/state/opencode
  }
}
```

OpenCode follows the **XDG Base Directory Specification** to organize user-level files:

> **Extended Explanation: XDG Base Directory Specification**
>
> The XDG (X Desktop Group) Base Directory Specification defines standard storage locations for user-level configuration, data, and cache files on Linux/macOS:
>
> | Environment Variable | Default Value | Purpose |
> |---------------------|---------------|---------|
> | `$XDG_CONFIG_HOME` | `~/.config` | Configuration files |
> | `$XDG_DATA_HOME` | `~/.local/share` | Data files |
> | `$XDG_CACHE_HOME` | `~/.cache` | Cache files |
> | `$XDG_STATE_HOME` | `~/.local/state` | State files |
>
> Following this specification means OpenCode's files won't "pollute" the user's home directory, and it makes migration and cleanup easier for users.

With these foundational patterns and directory structures understood, we now have a map for reading the source code analysis in subsequent chapters. Chapter 3 will examine OpenCode's overall architectural design from a higher-level perspective.
