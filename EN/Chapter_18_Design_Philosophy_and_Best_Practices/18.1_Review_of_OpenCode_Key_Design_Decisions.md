# 18.1 Review of OpenCode's Key Design Decisions

> **Model**: claude-opus-4-6 (anthropic/claude-opus-4-6)
> **Generation Date**: 2026-02-18

---

In the preceding seventeen chapters, we dissected every core module of OpenCode at the source code level. Now let us step back and examine these technical choices from the **designer's perspective** -- why were they made this way? What problems do they solve? What are the trade-offs?

This section distills the five most distinctive design decisions found in OpenCode's source code, helping readers understand "what good AI tool architecture should look like."

## 18.1.1 "Everything is a Namespace" -- The Extensive Use of TypeScript Namespaces

Open any core module of OpenCode, and you will see this pattern:

```typescript
// session/index.ts
export namespace Session {
  // Data model (Zod Schema)
  export const Info = z.object({
    id: Identifier.schema("session"),
    title: z.string(),
    // ...
  })
  export type Info = z.output<typeof Info>

  // Event definitions
  export const Event = {
    Created: BusEvent.define("session.created", z.object({ info: Info })),
    Updated: BusEvent.define("session.updated", z.object({ info: Info })),
  }

  // Business functions
  export async function create(input?: CreateInput) { /* ... */ }
  export async function list() { /* ... */ }
  export async function get(id: string) { /* ... */ }
}
```

The same pattern appears in `Agent`, `Provider`, `Tool`, `Permission`, `Snapshot`, `Bus` -- virtually all core modules are Namespaces rather than Classes.

### Why Not Use Classes?

The traditional object-oriented approach might look like this:

```typescript
// Traditional OOP style (OpenCode does NOT do this)
class SessionService {
  private storage: Storage
  private bus: EventBus

  constructor(storage: Storage, bus: EventBus) {
    this.storage = storage
    this.bus = bus
  }

  async create(input: CreateInput): Promise<Session> { /* ... */ }
  async get(id: string): Promise<Session> { /* ... */ }
}
```

Here are the reasons OpenCode chose Namespaces over Classes:

**1. Eliminating the Complexity of Constructors and Dependency Injection**

Classes need to be instantiated with `new` somewhere, and dependencies must be injected manually or through a DI container. Functions within a Namespace obtain dependencies directly through module imports, simplifying the initialization process:

```typescript
// Namespace style: dependencies resolved through module imports
import { Storage } from "../storage"
import { Bus } from "../bus"

export namespace Session {
  export async function create() {
    await Storage.write(...)  // Used directly, no injection needed
    Bus.publish(Session.Event.Created, { info })
  }
}
```

**2. Same-Name Coexistence of Types and Values**

TypeScript Namespaces allow the same name to serve as both a type and a value simultaneously. OpenCode leverages this feature extensively:

```typescript
export namespace Session {
  // Info is both a value (Zod Schema object)...
  export const Info = z.object({ /* ... */ })
  // ...and a type (TypeScript type inferred from the Schema)
  export type Info = z.output<typeof Info>
}

// Usage:
const session: Session.Info = await Session.get("ses_123")
//           ^-- type                   ^-- value (function)
```

This "dual identity of value and type" makes the API very clean.

**3. Better Tree-shaking**

Unreferenced exports in a Namespace can be removed by build tools. In contrast, instance methods on a Class are bundled into the final output even if they are never called.

**4. Alignment with Functional Programming Thinking**

The core logic of an AI programming assistant is a data pipeline (messages in -> processing -> messages out), which fits naturally with a functional style. Namespaces group related functions and types without imposing an object-oriented inheritance hierarchy.

### Trade-offs

This choice also has costs:

- **Difficult to Mock in Tests**: Functions within Namespaces call other modules directly, making them harder to replace in tests compared to interface injection.
- **Unfamiliar Pattern**: Most TypeScript projects use Classes or plain module exports; using Namespaces for business logic is uncommon.
- **Risk of Circular Dependencies**: Direct imports between modules (rather than indirect dependencies via interfaces) are more prone to circular dependencies.

OpenCode mitigates these issues through the `Instance.state()` pattern (see next section) and the event bus (Chapter 11).

## 18.1.2 The "Instance State" Pattern -- State Management Without Classes

Without Classes, how do you manage state? OpenCode invented the `Instance.state()` pattern:

```typescript
// Usage in provider/provider.ts
const state = Instance.state(
  // Initialization function: executed on first access
  async () => {
    const config = await Config.get()
    const providers: Record<string, Info> = {}
    const languages = new Map<string, LanguageModelV2>()
    // ...200+ lines of initialization logic
    return { models: languages, providers, sdk, modelLoaders }
  },
  // Cleanup function: executed when the instance is destroyed
  async (state) => {
    // Release resources
  }
)

// Usage: obtain state by calling it like a function
export async function list() {
  return state().then((s) => s.providers)
}
```

### How It Works

The core implementation of `Instance.state()` resides in `project/state.ts` (Section 3.3.2):

```typescript
export namespace State {
  const recordsByKey = new Map<string, Map<any, Entry>>()

  export function create<S>(
    root: () => string,  // Isolation key (typically a directory path)
    init: () => S,        // Lazy initialization function
    dispose?: (state: Awaited<S>) => Promise<void>  // Cleanup function
  ) {
    return () => {
      const key = root()
      let entries = recordsByKey.get(key)
      if (!entries) {
        entries = new Map()
        recordsByKey.set(key, entries)
      }
      const exists = entries.get(init)
      if (exists) return exists.state as S
      // Execute init() on first access, then reuse the cached result
      const state = init()
      entries.set(init, { state, dispose })
      return state
    }
  }
}
```

This is essentially a **lazy singleton pattern keyed by directory path**:

- **Lazy Initialization**: `init()` is executed only on the first call to `state()`, and subsequent calls return the cached value
- **Isolation by Directory**: The same module has independent state instances in different projects (directories)
- **Automatic Cleanup**: When `Instance.dispose()` is called, all registered `dispose` callbacks are executed

### Why Not Use Global Variables or a Singleton Class?

| Approach | Problem |
|----------|---------|
| Global variables | State conflicts during concurrent multi-project usage; no automatic cleanup |
| Singleton Class | Also cannot isolate by directory; uncertain constructor timing |
| `Instance.state()` | Automatic isolation by directory; lazy initialization; automatic cleanup |

This pattern is particularly well-suited to OpenCode's use case -- the Server may simultaneously handle requests for multiple projects (different directories), each requiring independent Provider instances, Session storage, Config configurations, and more.

## 18.1.3 "Zod-Driven" -- A Schema-First Data Model

You will rarely find hand-written TypeScript interfaces (`interface`) in OpenCode. Instead, **Zod Schemas serve as the Single Source of Truth**:

```typescript
// Traditional approach: interface + manual validation
interface Session {
  id: string
  title: string
  time: { created: number; updated: number }
}
function validate(data: unknown): Session { /* hand-written validation logic */ }

// OpenCode approach: Zod Schema does it all in one step
const Session = z.object({
  id: Identifier.schema("session"),
  title: z.string(),
  time: z.object({ created: z.number(), updated: z.number() }),
})
type Session = z.output<typeof Session>
// Validation: Session.parse(data) or Session.safeParse(data)
```

### One Schema, Multiple Uses

Zod Schemas in OpenCode serve far more purposes than just "data validation":

| Use Case | Implementation |
|----------|---------------|
| TypeScript type | `z.output<typeof Schema>` or `z.infer<typeof Schema>` |
| Runtime validation | `Schema.parse(data)` throws exceptions; `Schema.safeParse(data)` returns a result |
| Function parameter validation | `fn(schema, callback)` wrapper (`util/fn.ts`) |
| OpenAPI specification | Hono + Zod auto-generates API documentation |
| Tool parameter definition | `tool.schema.string()` passed directly to the LLM |
| Event definition | `BusEvent.define("name", schema)` for type-safe events |
| Configuration validation | Config uses Zod Schemas to validate `opencode.json` |

The **`fn()` wrapper** is a particularly elegant design (`util/fn.ts`):

```typescript
export function fn<T extends z.ZodType, Result>(
  schema: T,
  cb: (input: z.infer<T>) => Result
) {
  const result = (input: z.infer<T>) => {
    const parsed = schema.parse(input)  // Runtime validation
    return cb(parsed)
  }
  result.force = (input: z.infer<T>) => cb(input)  // Skip validation (for performance)
  result.schema = schema  // Expose Schema for external introspection
  return result
}

// Usage
export const create = fn(
  z.object({ title: z.string().optional() }),
  async (input) => {
    // input is validated and type-safe
  }
)
create.schema // The parameter Schema can be read for documentation generation
```

### The Schema-First Philosophy

The core idea behind this pattern is: **the shape of data should be defined only once, then reused across all scenarios -- the type system, runtime validation, documentation generation, and more**. This eliminates inconsistencies between interface definitions and validation logic, and reduces the burden of manually maintaining multiple type definitions.

## 18.1.4 "Txt Templates" -- Separating Prompts from Code

OpenCode's Agent Prompts are stored in standalone `.txt` files:

```
packages/opencode/src/agent/prompt/
├── anthropic.txt       # System Prompt for Claude models
├── beast.txt           # System Prompt for GPT models
├── gemini.txt          # System Prompt for Gemini models
├── qwen.txt            # System Prompt for other models
├── codex_header.txt    # Extra prefix for GPT-5
├── explore.txt         # Prompt for the Explore Agent
├── compaction.txt      # Context compaction Prompt
├── title.txt           # Title generation Prompt
└── summary.txt         # Summary generation Prompt
```

These `.txt` files are imported as strings at build time:

```typescript
import PROMPT_ANTHROPIC from "./prompt/anthropic.txt"
import PROMPT_EXPLORE from "./prompt/explore.txt"

// Used directly as strings
const systemPrompt = PROMPT_ANTHROPIC
```

### Why Separate Them?

**1. Prompts Iterate Far More Frequently Than Code**

During AI application development, Prompts may be adjusted 10 times more frequently than code. Placing Prompts in standalone files allows prompt engineers (or AI itself) to make quick modifications without needing to understand the TypeScript code.

**2. Readability**

A good System Prompt can be hundreds of lines long (`anthropic.txt` is quite lengthy). Embedding such long texts within TypeScript code would severely harm code readability.

**3. Git Diff Friendly**

Standalone `.txt` files are immediately clear in Git Diffs -- which Prompts were modified and what changed. If Prompts were mixed into TypeScript code, the Diffs would be "drowned out" by code changes.

**4. Multi-Model Adaptation**

Different LLMs require different styles of Prompts (Section 6.4.1). Standalone files turn model adaptation into "selecting a different .txt file," rather than using extensive if-else statements in code.

### Tool Descriptions Also Use .txt

Each built-in tool in OpenCode also has a corresponding `.txt` description file (Section 5.3.7), with the tool's `description` field read from these files. This means the "instruction manual" that tools present to the LLM can be maintained independently of the tool's execution logic.

## 18.1.5 "Embedded Server" -- The Web-ification Trend for CLI Tools

On the surface, OpenCode is a CLI tool, but internally it runs a full HTTP Server (based on the Hono framework, Section 3.1):

```
User Terminal
    |
    v
+----------+     +------------------------------+
|  TUI     |---->|  Embedded HTTP Server (Hono)  |
| (Ink)    |     |                              |
+----------+     |  /session/* -> Session API    |
                 |  /config/*  -> Config API     |
+----------+     |  /provider/* -> Provider API  |
|  Web UI  |---->|  /mcp/*    -> MCP API        |
|(SolidJS) |     |  /events   -> SSE Push       |
+----------+     |  /doc      -> OpenAPI Docs   |
                 +------------------------------+
+----------+              |
|  VSCode  |--------------+
| Extension|
+----------+
```

### Why Does a CLI Need a Server?

**1. Unified Multi-Client Support**

OpenCode is not just a CLI -- it also has a Web UI (`packages/app/`), a desktop application (`packages/desktop/`), and a VSCode extension (`sdks/vscode/`). The embedded Server provides a unified API, allowing all clients to share the same business logic.

**2. Separation of Concerns**

The TUI handles user interaction (rendering, input handling), while the Server handles business logic (Session management, LLM invocations, tool execution). This allows both layers to evolve independently -- for example, the TUI can be rewritten without modifying the Server.

**3. Real-Time Communication**

The Server pushes real-time events to clients via SSE (Server-Sent Events, Section 3.1.4) -- streaming text output, tool invocation status changes, session updates, and more. This is far more elegant than having the TUI poll or use callbacks directly.

**4. Testability**

API routes can be integration-tested with standard HTTP testing tools, without the need to launch a full TUI environment.

**5. ACP (Agent Client Protocol) Support**

The embedded Server enables OpenCode to serve as an ACP Agent callable by other applications (Section 16.3), which a pure CLI architecture cannot achieve.

### The Universality of This Design Pattern

The "embedded Server" design pattern is becoming a trend in modern CLI tools. Similar examples include:

- **Docker CLI**: Actually communicates with the Docker Daemon via a REST API
- **kubectl**: Interacts with the Kubernetes API Server over HTTP
- **VS Code**: The entire editor runs within Electron, communicating via internal IPC

OpenCode applies this pattern to the AI programming assistant domain, ensuring that its "terminal-first" design philosophy does not limit its potential for multi-platform expansion.

---

These five design decisions together form OpenCode's "technical personality" -- functional rather than object-oriented, schema-driven rather than interface-driven, data-separated rather than mixed, server-based rather than monolithic CLI. They are not necessarily the "only correct" choices, but in the rapidly iterating field of AI programming assistants, these choices give OpenCode excellent maintainability and extensibility.
