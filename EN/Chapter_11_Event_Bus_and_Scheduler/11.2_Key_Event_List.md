# 11.2 Key Event List

> **Model**: claude-opus-4-6 (anthropic/claude-opus-4-6)
> **Generation Date**: 2026-02-17

---

In the previous section, we introduced the architectural design of the event bus. This section systematically catalogs all events defined in OpenCode. As of version 1.2.5, OpenCode defines a total of **46 events**, distributed across 24 source files, covering everything from session management to file monitoring, from permission requests to IDE installation.

Understanding the meaning and timing of these events is crucial for the chapters that follow (especially Chapter 12 on TUI implementation and Chapter 13 on the Plugin system) -- because TUI interface refreshing and the Plugin hook mechanism are both heavily event-driven.

## 11.2.1 Session-Related Events

Session is the most event-dense module, defining 12 events that cover the complete lifecycle of sessions, messages, compaction, and Todos.

### Session-Level Events

```typescript
// session/index.ts
Session.Event = {
  Created:  BusEvent.define("session.created",  z.object({ info: Session.Info })),
  Updated:  BusEvent.define("session.updated",  z.object({ info: Session.Info })),
  Deleted:  BusEvent.define("session.deleted",  z.object({ info: Session.Info })),
  Diff:     BusEvent.define("session.diff",     z.object({
    sessionID: z.string(),
    diff: Snapshot.FileDiff.array(),
  })),
  Error:    BusEvent.define("session.error",    z.object({
    sessionID: z.string().optional(),
    error: MessageV2.Assistant.shape.error,
  })),
}
```

| Event | Trigger Timing | Typical Consumer |
|------|---------|-----------|
| `session.created` | A new session is created | TUI updates the session list |
| `session.updated` | Session metadata is updated (title, timestamp, etc.) | TUI refreshes the session title |
| `session.deleted` | A session is deleted | TUI removes the session entry |
| `session.diff` | A session produced file changes | TUI displays a diff summary |
| `session.error` | A session encountered an error (e.g., API call failure) | TUI displays an error message |

### Status Events

```typescript
// session/status.ts
SessionStatus.Event = {
  Status: BusEvent.define("session.status", z.object({
    sessionID: z.string(),
    status: SessionStatus.Info,
  })),
  Idle: BusEvent.define("session.idle", z.object({
    sessionID: z.string(),
  })),
}
```

`session.status` is triggered when the session state transitions between `idle` / `busy` / `pending`, and `session.idle` is a specialization of `status` -- triggered only when transitioning to the idle state. The TUI uses these events to update the status indicator (e.g., showing a loading animation or re-enabling the input field).

### Message Events

```typescript
// session/message-v2.ts
MessageV2.Event = {
  Updated:     BusEvent.define("message.updated",      z.object({ sessionID, messageID, message })),
  Removed:     BusEvent.define("message.removed",      z.object({ sessionID, messageID })),
  PartUpdated: BusEvent.define("message.part.updated",  z.object({ sessionID, messageID, part })),
  PartRemoved: BusEvent.define("message.part.removed",  z.object({ sessionID, messageID, partID })),
}
```

Message events have very fine granularity -- there are not only message-level updates and deletions, but also **Part-level** updates and deletions. Recall from Chapter 4 that a Message is composed of multiple Parts (text, chain-of-thought, tool calls, etc.). Part-level events enable the TUI to perform **incremental rendering** -- when the AI is streaming output, each time a `text-delta` is received, `message.part.updated` notifies the TUI to update the corresponding Part without needing to re-render the entire message.

### Compaction and Todo Events

```typescript
// session/compaction.ts
Compaction.Event = {
  Compacted: BusEvent.define("session.compacted", z.object({
    sessionID: z.string(),
    messageIDs: z.array(z.string()),
  })),
}

// session/todo.ts
Todo.Event = {
  Updated: BusEvent.define("todo.updated", z.object({
    sessionID: z.string(),
    todos: z.array(Todo.Info),
  })),
}
```

`session.compacted` is triggered after context compaction completes, carrying the list of compacted message IDs. `todo.updated` is triggered when the Todo list changes, and the TUI uses it to refresh the Todo panel.

## 11.2.2 MCP-Related Events

```typescript
// mcp/index.ts
export const ToolsChanged = BusEvent.define(
  "mcp.tools.changed",
  z.object({ server: z.string() }),
)

export const BrowserOpenFailed = BusEvent.define(
  "mcp.browser.open.failed",
  z.object({
    mcpName: z.string(),
    url: z.string(),
  }),
)
```

| Event | Trigger Timing | Purpose |
|------|---------|------|
| `mcp.tools.changed` | The MCP Server's tool list has changed | Refresh the tool registry so new tools become available to the Agent |
| `mcp.browser.open.failed` | Browser could not be opened during MCP OAuth authentication | Display a prompt for the user to manually open the URL |

The `mcp.tools.changed` event was mentioned in Chapter 8 -- MCP Servers support the `ToolsChanged` notification. When the server-side tool list is updated, the Client receives the notification and publishes this event, triggering a reload of the tool registry.

## 11.2.3 Permission-Related Events

The permission system defines two groups of events, located in the new (`permission/next.ts`) and legacy (`permission/index.ts`) permission modules respectively:

```typescript
// permission/next.ts (new permission system)
PermissionNext.Event = {
  Asked:   BusEvent.define("permission.asked",   PermissionNext.Request),
  Replied: BusEvent.define("permission.replied",  z.object({
    sessionID: z.string(),
    requestID: z.string(),
    action: PermissionNext.Action,
    always: z.boolean().optional(),
  })),
}

// permission/index.ts (legacy permission system)
Permission.Event = {
  Updated: BusEvent.define("permission.updated", Permission.Info),
  Replied: BusEvent.define("permission.replied", z.object({
    requestID: z.string(),
    action: z.string(),
  })),
}
```

The `permission.asked` event is the most critical event in the permission system -- when the Agent attempts to perform an operation requiring user authorization, the permission engine publishes this event. Upon receiving the event, the TUI pops up a permission confirmation dialog, and after the user makes a decision, the result is sent back to the permission engine via the `permission.replied` event.

This is a classic **Request-Response Event Pair** -- the publisher emits a request event and then subscribes to the response event to obtain the result. This pattern avoids direct dependencies between modules: the permission engine does not need to directly call TUI code, and the TUI does not need to know the implementation details of the permission engine.

## 11.2.4 Server-Related Events

```typescript
// server/event.ts
ServerEvent = {
  Connected: BusEvent.define("server.connected", z.object({})),
  Disposed:  BusEvent.define("global.disposed",  z.object({})),
}

// bus/index.ts
Bus.InstanceDisposed = BusEvent.define(
  "server.instance.disposed",
  z.object({ directory: z.string() }),
)

// server/routes/global.ts
GlobalDisposedEvent = BusEvent.define("global.disposed", z.object({}))
```

| Event | Trigger Timing | Purpose |
|------|---------|------|
| `server.connected` | The HTTP Server has started and is ready | Notifies the TUI that it can establish an SSE connection |
| `global.disposed` | Global resources are being released | Clean up global state |
| `server.instance.disposed` | A specific Instance is being destroyed | Clean up resources and subscriptions for that Instance |

## 11.2.5 File System-Related Events

```typescript
// file/index.ts
File.Event = {
  Edited: BusEvent.define("file.edited", z.object({
    file: z.string(),
    sessionID: z.string(),
  })),
}

// file/watcher.ts
FileWatcher.Event = {
  Updated: BusEvent.define("file.watcher.updated", z.object({
    file: z.string(),
    event: z.union([
      z.literal("add"),
      z.literal("change"),
      z.literal("unlink"),
    ]),
  })),
}
```

`file.edited` is published by OpenCode's tools (such as Edit, Write) after modifying a file, while `file.watcher.updated` is published by the file system monitor (based on `@parcel/watcher`) when it detects external file changes. The difference between the two is:

- `file.edited`: Events generated by the Agent actively modifying files, carrying a `sessionID` to identify which session initiated the modification.
- `file.watcher.updated`: External changes (user manual edits, modifications by other tools, etc.), carrying the change type (add/change/unlink).

## 11.2.6 Other Module Events

### PTY (Pseudo-Terminal) Events

```typescript
// pty/index.ts
Pty.Event = {
  Created: BusEvent.define("pty.created",  z.object({ info: Pty.Info })),
  Updated: BusEvent.define("pty.updated",  z.object({ info: Pty.Info })),
  Exited:  BusEvent.define("pty.exited",   z.object({ id, exitCode: z.number() })),
  Deleted: BusEvent.define("pty.deleted",  z.object({ id })),
}
```

### Question (Interactive Q&A) Events

```typescript
// question/index.ts
Question.Event = {
  Asked:    BusEvent.define("question.asked",    Question.Request),
  Replied:  BusEvent.define("question.replied",  z.object({
    sessionID, requestID, answers: z.array(Answer)
  })),
  Rejected: BusEvent.define("question.rejected", z.object({
    sessionID, requestID
  })),
}
```

Question events are similar to Permission events -- they also form request-response pairs. When the Agent asks the user a question via the `question` tool, it publishes `question.asked`. When the user answers, `question.replied` is triggered. If the user declines to answer, `question.rejected` is triggered.

### Project and VCS Events

```typescript
// project/project.ts
Project.Event = {
  Updated: BusEvent.define("project.updated", Project.Info),
}

// project/vcs.ts
VCS.Event = {
  BranchUpdated: BusEvent.define("vcs.branch.updated", z.object({
    branch: z.string(),
  })),
}
```

### LSP Events

```typescript
// lsp/index.ts
LSP.Event = {
  Updated: BusEvent.define("lsp.updated", z.object({})),
}

// lsp/client.ts
LSPClient.Event = {
  Diagnostics: BusEvent.define("lsp.diagnostics", z.object({
    uri: z.string(),
    diagnostics: z.array(/* ... */),
  })),
}
```

### Other Events

```typescript
// command/index.ts
Command.Event = {
  Executed: BusEvent.define("command.executed", z.object({ command: z.string() })),
}

// worktree/index.ts  (covered in Section 10.4)
Worktree.Event = {
  Ready:  BusEvent.define("worktree.ready",  z.object({ name, branch })),
  Failed: BusEvent.define("worktree.failed", z.object({ message })),
}

// installation/index.ts
Installation.Event = {
  Updated:         BusEvent.define("installation.updated", z.object({ version })),
  UpdateAvailable: BusEvent.define("installation.update_available", z.object({
    current, latest
  })),
}

// ide/index.ts
IDE.Event = {
  Installed: BusEvent.define("ide.installed", z.object({ name })),
}

// cli/cmd/tui/event.ts
TuiEvent = {
  PromptAppend:   BusEvent.define("tui.prompt.append",   z.object({ text: z.string() })),
  CommandExecute: BusEvent.define("tui.command.execute",  z.object({ text: z.string() })),
  ToastShow:      BusEvent.define("tui.toast.show",      z.object({
    title, description, action?,
  })),
  SessionSelect:  BusEvent.define("tui.session.select",  z.object({ sessionID })),
}
```

TUI events are somewhat special -- they are not published by backend modules, but are used internally within the TUI for inter-component communication. For example, `tui.toast.show` is published by any component and subscribed to by the Toast component to display notifications.

## 11.2.7 Event Panorama

Categorizing all events by module produces the following panoramic view:

```
Session Domain (12 events)
├── session.created / updated / deleted / diff / error
├── session.status / idle
├── session.compacted
├── message.updated / removed
├── message.part.updated / removed
└── todo.updated

Interaction Domain (7 events)
├── permission.asked / replied / updated
├── question.asked / replied / rejected
└── command.executed

MCP Domain (2 events)
├── mcp.tools.changed
└── mcp.browser.open.failed

File System Domain (2 events)
├── file.edited
└── file.watcher.updated

PTY Domain (4 events)
├── pty.created / updated / exited / deleted

Infrastructure Domain (7 events)
├── server.connected / server.instance.disposed
├── global.disposed
├── project.updated / vcs.branch.updated
├── lsp.updated / lsp.diagnostics
└── installation.updated / update_available

TUI Internal Domain (4 events)
├── tui.prompt.append / tui.command.execute
├── tui.toast.show / tui.session.select

Other Domain (4 events)
├── worktree.ready / worktree.failed
└── ide.installed
```

## 11.2.8 Config Change Events

It is worth noting specifically that OpenCode's configuration changes are **not** communicated through Bus events. The configuration system uses a different mechanism -- when a configuration file is modified, the file monitor (FileWatcher) detects the change and triggers a configuration reload. This is because configuration changes typically need to take effect immediately (e.g., updating an API key), and the asynchronous nature of the event bus could introduce delays.

## 11.2.9 Summary

The 46 events constitute the "language" of inter-module communication in OpenCode. Several design patterns are worth noting:

1. **Layered Event Granularity**: From coarse-grained (`session.created`) to fine-grained (`message.part.updated`), different consumers can choose the level of granularity they need.

2. **Request-Response Event Pairs**: `permission.asked/replied` and `question.asked/replied` demonstrate how events can be used to implement asynchronous request-response communication, avoiding direct call dependencies between modules.

3. **Domain Aggregation**: Events naturally aggregate by business domain, and the prefixes in their names (`session.`, `mcp.`, `pty.`) make event types immediately recognizable.

4. **Schema as Documentation**: Each event's Zod Schema precisely defines the data structure carried by the event, serving both as the basis for type checking and as the data source for automatic API documentation generation.
