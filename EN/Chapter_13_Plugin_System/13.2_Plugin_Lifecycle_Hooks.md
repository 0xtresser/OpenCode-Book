# 13.2 Plugin Lifecycle Hooks

> **Model**: claude-opus-4-6 (anthropic/claude-opus-4-6)
> **Generation Date**: 2026-02-17

---

In the previous section, we gave an overview of the Plugin interface type definitions. This section takes a deep dive into the invocation timing, input/output structure, and typical usage of each hook.

## 13.2.1 tool: Registering Custom Tools

```typescript
tool?: { [key: string]: ToolDefinition }
```

`tool` is not a function hook but a tool definition dictionary. When a Plugin returns its Hooks object, the `tool` field is read by the ToolRegistry and registered as available tools.

**Invocation timing**: During Instance initialization, after Plugin loading is complete.
**Scope**: Registered tools are available to all Agents (subject to permission rules).

## 13.2.2 config: Configuration Injection

```typescript
config?: (input: Config) => Promise<void>
```

**Invocation timing**: After Plugin loading is complete, called within `Plugin.init()`.
**Purpose**: Plugins can read and modify the global configuration. This is primarily used when a Plugin needs to dynamically adjust its behavior based on the current configuration.

## 13.2.3 chat.params: LLM Call Parameter Interception

```typescript
"chat.params"?: (
  input: {
    sessionID: string
    agent: string
    model: Model
    provider: ProviderContext
    message: UserMessage
  },
  output: {
    temperature: number
    topP: number
    topK: number
    options: Record<string, any>
  },
) => Promise<void>
```

**Invocation timing**: Before each LLM call, triggered within `LLM.stream()`.
**Purpose**: Modify the parameters sent to the LLM -- temperature, Top-P, Top-K, and Provider-specific options.

**Typical usage**: oh-my-opencode uses this hook to inject the `effort` parameter for Anthropic models (controlling the model's reasoning depth):

```typescript
"chat.params": async (input, output) => {
  if (input.provider.info.id === "anthropic") {
    output.options["anthropic"] = {
      thinking: { type: "enabled", budget_tokens: 10000 }
    }
  }
}
```

## 13.2.4 chat.message: Message Interception and Modification

```typescript
"chat.message"?: (
  input: {
    sessionID: string
    agent?: string
    model?: { providerID: string; modelID: string }
    messageID?: string
    variant?: string
  },
  output: { message: UserMessage; parts: Part[] },
) => Promise<void>
```

**Invocation timing**: After the user sends a message, before it is sent to the LLM.
**Purpose**: Modify user message content, or inject additional Parts into the message (such as file references or contextual information).

**Typical usage**: Automatically inject project conventions into user messages:

```typescript
"chat.message": async (input, output) => {
  output.parts.push({
    type: "text",
    text: "[CONTEXT] Project uses TypeScript with strict mode enabled."
  })
}
```

## 13.2.5 experimental.chat.messages.transform: Message List Transformation

```typescript
"experimental.chat.messages.transform"?: (
  input: {},
  output: {
    messages: {
      info: Message
      parts: Part[]
    }[]
  },
) => Promise<void>
```

**Invocation timing**: When building the message list to be sent to the LLM.
**Purpose**: Transform the entire message history -- you can filter, reorder, or merge messages. This is a more powerful hook than `chat.message` (which operates on a single message).

**Note**: The `experimental.` prefix indicates that this is an experimental API and may change in the future.

## 13.2.6 experimental.chat.system.transform: System Prompt Transformation

```typescript
"experimental.chat.system.transform"?: (
  input: { sessionID?: string; model: Model },
  output: { system: string[] },
) => Promise<void>
```

**Invocation timing**: When building the System Prompt.
**Purpose**: Modify the list of system prompt segments sent to the LLM. You can add, remove, or replace system prompt paragraphs.

This is the primary hook that oh-my-opencode uses to inject its extensive behavioral instructions -- the entire behavioral specification of the Sisyphus Agent is injected through this hook.

## 13.2.7 event: Event Listening

```typescript
event?: (input: { event: Event }) => Promise<void>
```

**Invocation timing**: Whenever any event is published through the Bus.
**Purpose**: Listen for system events and perform side effects.

In `Plugin.init()`, OpenCode forwards all Bus events to Plugins via a wildcard subscription:

```typescript
// plugin/index.ts
export async function init() {
  Bus.subscribeAll(async (input) => {
    const hooks = await state().then((x) => x.hooks)
    for (const hook of hooks) {
      hook["event"]?.({ event: input })
    }
  })
}
```

## 13.2.8 tool.execute.before / tool.execute.after: Pre/Post Tool Execution Hooks

```typescript
"tool.execute.before"?: (
  input: { tool: string; sessionID: string; callID: string },
  output: { args: any },
) => Promise<void>

"tool.execute.after"?: (
  input: { tool: string; sessionID: string; callID: string },
  output: { title: string; output: string; metadata: any },
) => Promise<void>
```

**Invocation timing**: Before/after each tool execution.
**Purpose**:
- `before`: Modify the tool's input arguments, or log activity.
- `after`: Modify the tool's output, or perform post-processing.

**Typical usage**: Operation logging:

```typescript
"tool.execute.before": async (input, output) => {
  console.log(`[${input.tool}] called with:`, output.args)
}
```

## 13.2.9 experimental.session.compacting: Compaction Process Hook

```typescript
"experimental.session.compacting"?: (
  input: { sessionID: string },
  output: { context: string[]; prompt?: string },
) => Promise<void>
```

**Invocation timing**: Before Compaction (context compression) is executed.
**Purpose**:
- Inject additional information into the compaction context (via the `context` array).
- Or completely replace the compaction prompt (by setting `prompt`).

## 13.2.10 Hook Triggering Mechanism

All hooks are triggered through the unified `Plugin.trigger()` function:

```typescript
// plugin/index.ts
export async function trigger<Name extends keyof Hooks>(
  name: Name,
  input: Input,
  output: Output
): Promise<Output> {
  if (!name) return output
  for (const hook of await state().then((x) => x.hooks)) {
    const fn = hook[name]
    if (!fn) continue
    await fn(input, output)  // Execute sequentially; each Plugin can modify output
  }
  return output
}
```

Key design decisions:
1. **Chained execution**: Hooks of the same name from multiple Plugins are executed in registration order.
2. **Shared output**: All Plugins share the same `output` reference, so subsequent Plugins see the modifications made by earlier ones.
3. **Sequential await**: Hook functions are executed sequentially with `await`, ensuring that one Plugin's modifications are complete before the next Plugin runs.
