# 6.2 Built-in Agent: build

> **Model**: claude-opus-4-6 (anthropic/claude-opus-4-6)
> **Generation Date**: 2026-02-17

---

OpenCode includes 7 built-in Agents that form the "Agent ecosystem skeleton" of the system. Among them, `build` is the most central -- it is the default Agent that users interact with, handling the vast majority of coding tasks. This section will analyze the `build` Agent and other built-in Agents' configurations and design in detail.

## 6.2.1 The `build` Agent: The Default Protagonist

```typescript
build: {
  name: "build",
  description: "The default agent. Executes tools based on configured permissions.",
  options: {},
  permission: PermissionNext.merge(
    defaults,
    PermissionNext.fromConfig({
      question: "allow",
      plan_enter: "allow",
    }),
    user,
  ),
  mode: "primary",
  native: true,
},
```

`build` is OpenCode's "all-purpose Agent" -- it has no dedicated Prompt (it uses the Provider's default Prompt), no specified model (it uses the global default model), and no step limit. Its core characteristics are reflected in its permission configuration.

### Default Permissions of `build`

Permissions are composed through three layers of merging to form the final rule set:

**Layer 1: `defaults` (Global Default Permissions)**

```typescript
const defaults = PermissionNext.fromConfig({
  "*": "allow",                    // Allow all tools by default
  doom_loop: "ask",                // Ask user when loop detection triggers
  external_directory: {
    "*": "ask",                    // Accessing external directories requires asking by default
    [Truncate.GLOB]: "allow",      // Truncated output directory is allowed
    ...Object.fromEntries(
      skillDirs.map((dir) => [path.join(dir, "*"), "allow"])
    ),                             // Skill directories are allowed
  },
  question: "deny",                // question tool is denied by default
  plan_enter: "deny",              // Entering Plan mode is denied by default
  plan_exit: "deny",               // Exiting Plan mode is denied by default
  read: {
    "*": "allow",                  // Allow reading all files
    "*.env": "ask",                // Reading .env files requires asking
    "*.env.*": "ask",              // Reading .env.* files requires asking
    "*.env.example": "allow",      // But .env.example is allowed directly
  },
})
```

This set of default permissions reveals several security design principles:

1. **Open but bounded**: `"*": "allow"` indicates that the Agent is trusted to use all tools by default, but additional checkpoints are set for sensitive operations (such as reading environment variable files or accessing directories outside the project).

2. **Environment variable protection**: `.env` files typically contain API keys, database passwords, and other sensitive information. OpenCode borrows from GitHub's `Node.gitignore` pattern, implementing an "ask before reading" policy for `*.env` and `*.env.*` files, while allowing free access to `.env.example` (example configuration files).

3. **External directory control**: The `external_directory` permission restricts Agent access to files outside the project directory. It defaults to `"ask"` -- the Agent can access them, but user confirmation is required. This prevents AI from accidentally modifying system files or code from other projects.

**Layer 2: `build`-Specific Permission Overlay**

```typescript
PermissionNext.fromConfig({
  question: "allow",     // build is allowed to use the question tool (ask the user)
  plan_enter: "allow",   // build is allowed to enter Plan mode
})
```

As the primary Agent, `build` needs the ability to interact with users (`question`) and to plan before complex tasks (`plan_enter`). These capabilities are typically unnecessary for sub-Agents -- sub-Agents execute specific tasks and do not need to "ask questions back to the user."

**Layer 3: User-Defined Permissions**

```typescript
const user = PermissionNext.fromConfig(cfg.permission ?? {})
```

Users can define custom permission rules in `opencode.json`, which are merged with the highest priority, overriding the default values from the previous two layers.

### Permission Merging Semantics

The `PermissionNext.merge()` function merges multiple permission layers in order. Later rules override earlier rules with the same name:

```typescript
PermissionNext.merge(defaults, buildSpecific, user)
//                    ^ lowest priority      ^ middle     ^ highest priority
```

This means that if a user sets `"bash": "deny"` in their configuration, even though `defaults` allows all tools and `build` has no explicit restriction on bash, the `build` Agent will ultimately be unable to use the bash tool.

## 6.2.2 The `plan` Agent: Read-Only Planning Mode

```typescript
plan: {
  name: "plan",
  description: "Plan mode. Disallows all edit tools.",
  options: {},
  permission: PermissionNext.merge(
    defaults,
    PermissionNext.fromConfig({
      question: "allow",
      plan_exit: "allow",
      external_directory: {
        [path.join(Global.Path.data, "plans", "*")]: "allow",
      },
      edit: {
        "*": "deny",
        [path.join(".opencode", "plans", "*.md")]: "allow",
        [/* plan file path */]: "allow",
      },
    }),
    user,
  ),
  mode: "primary",
  native: true,
},
```

The `plan` Agent is the "read-only version" of `build` -- it can read code, search files, and discuss solutions with the user, but **editing any files is prohibited**, with the sole exception being plan files in the `.opencode/plans/` directory.

This design implements a "plan first, execute later" workflow:

1. The user enters Plan mode (via the `plan_enter` tool or the `/plan` command).
2. The Agent switches to the `plan` role, which can only read and analyze code.
3. The Agent formulates a plan and writes it to the `.opencode/plans/` directory.
4. After the user confirms, the Agent exits Plan mode (`plan_exit`) and returns to the `build` role to begin execution.

The system injects the corresponding Prompt during mode switches: `plan.txt` is injected when entering Plan mode (emphasizing read-only constraints), and `build-switch.txt` is injected when exiting (lifting the read-only restriction).

## 6.2.3 The `general` Agent: General-Purpose Sub-Agent

```typescript
general: {
  name: "general",
  description: `General-purpose agent for researching complex questions
    and executing multi-step tasks. Use this agent to execute
    multiple units of work in parallel.`,
  permission: PermissionNext.merge(
    defaults,
    PermissionNext.fromConfig({
      todoread: "deny",
      todowrite: "deny",
    }),
    user,
  ),
  options: {},
  mode: "subagent",
  native: true,
},
```

`general` is the default sub-Agent -- when the primary Agent uses the Task tool to delegate a subtask without specifying a particular Agent, `general` is used.

Notably, `general` **disables the Todo tools** (`todoread` and `todowrite` are set to `"deny"`). This is because the Todo list is a coordination tool for the primary Agent. Sub-Agents managing their own Todos would cause Todo list confusion -- multiple sub-Agents simultaneously modifying the same Todo list could produce conflicts.

## 6.2.4 The `explore` Agent: Search Specialist

```typescript
explore: {
  name: "explore",
  permission: PermissionNext.merge(
    defaults,
    PermissionNext.fromConfig({
      "*": "deny",           // Deny all tools by default
      grep: "allow",         // Only allow search-type tools
      glob: "allow",
      list: "allow",
      bash: "allow",
      webfetch: "allow",
      websearch: "allow",
      codesearch: "allow",
      read: "allow",
      external_directory: {
        [Truncate.GLOB]: "allow",
      },
    }),
    user,
  ),
  description: `Fast agent specialized for exploring codebases...`,
  prompt: PROMPT_EXPLORE,
  options: {},
  mode: "subagent",
  native: true,
},
```

`explore` is a **highly restricted specialist Agent**. Its permission strategy is "deny by default, allow by whitelist" (`"*": "deny"` + specific tools set to `"allow"`), forming a sharp contrast with `build`'s "allow by default, deny by blacklist" approach.

`explore` can only use search-type tools (`grep`, `glob`, `read`, `bash`, etc.) -- it cannot edit files, create Todos, or delegate subtasks. This design ensures that `explore` is a **safe read-only operator** -- the primary Agent can confidently delegate search tasks to it without worrying about side effects.

`explore` also has a dedicated Prompt (`prompt/explore.txt`):

```
You are a file search specialist. You excel at thoroughly navigating
and exploring codebases.

Your strengths:
- Rapidly finding files using glob patterns
- Searching code and text with powerful regex patterns
- Reading and analyzing file contents

Guidelines:
- Do not create any files, or run bash commands that modify
  the user's system state in any way
```

The Prompt reinforces the "read-only" constraint again -- even if the permission system accidentally allows a write operation, the Prompt layer explicitly prohibits modification behavior. This **dual safeguard** (permissions + Prompt) is a typical pattern in Agent security design.

## 6.2.5 Utility Agents: `compaction`, `title`, `summary`

These three Agents all have the `hidden: true` attribute -- users cannot interact with them directly. They serve internal system functions:

### The `compaction` Agent

```typescript
compaction: {
  name: "compaction",
  mode: "primary",
  native: true,
  hidden: true,
  prompt: PROMPT_COMPACTION,
  permission: PermissionNext.merge(defaults,
    PermissionNext.fromConfig({ "*": "deny" }), user),
  options: {},
},
```

Dedicated to generating context compaction summaries. All tools are disabled (`"*": "deny"`) -- it only needs to read conversation history and generate summary text, requiring no tools whatsoever.

### The `title` Agent

```typescript
title: {
  name: "title",
  mode: "primary",
  native: true,
  hidden: true,
  temperature: 0.5,       // Moderate randomness
  prompt: PROMPT_TITLE,
  permission: PermissionNext.merge(defaults,
    PermissionNext.fromConfig({ "*": "deny" }), user),
  options: {},
},
```

Used to generate session titles. Notably, it sets `temperature: 0.5` -- title generation requires some creativity (it shouldn't always generate identical titles), but it shouldn't be too wild either.

### The `summary` Agent

```typescript
summary: {
  name: "summary",
  mode: "primary",
  native: true,
  hidden: true,
  prompt: PROMPT_SUMMARY,
  permission: PermissionNext.merge(defaults,
    PermissionNext.fromConfig({ "*": "deny" }), user),
  options: {},
},
```

Used to generate PR-style session summaries. Its Prompt requires "2-3 sentences, first person, describe only the changes not the process."

## 6.2.6 Special Handling of Truncate.GLOB

After all Agents have been initialized, the system performs a global patching step:

```typescript
// Ensure all Agents are allowed to access the Truncate output directory
for (const name in result) {
  const agent = result[name]
  const explicit = agent.permission.some((r) => {
    if (r.permission !== "external_directory") return false
    if (r.action !== "deny") return false
    return r.pattern === Truncate.GLOB
  })
  if (explicit) continue

  result[name].permission = PermissionNext.merge(
    result[name].permission,
    PermissionNext.fromConfig({ external_directory: { [Truncate.GLOB]: "allow" } }),
  )
}
```

Recalling the content from Chapter 5, when tool output is too long, the system truncates the content and writes it to a temporary file (at the path defined by `Truncate.GLOB`). To allow Agents to read the complete output after truncation, the system ensures all Agents have permission to access the truncated output directory -- **unless the user has explicitly denied that path**.

This "unless explicitly denied" check (the `explicit` variable) reflects respect for user intent: if the user truly wants to prevent a certain Agent from accessing truncated output, the system will not override that decision.

## 6.2.7 Design Philosophy of Built-in Agents

Looking across the design of these 7 built-in Agents, several design principles can be distilled:

1. **Principle of least privilege**: Each Agent possesses only the minimum permissions required to fulfill its responsibilities. `explore` can only search, and `compaction` cannot use any tools at all.

2. **Separation of concerns**: Each Agent has a clear, single responsibility. `title` only generates titles, `summary` only generates summaries -- no single Agent both generates titles and edits files.

3. **Dual safety**: The permission system (hard constraints) and Prompt (soft constraints) jointly govern Agent behavior. Even if one layer fails, the other still provides protection.

4. **User priority**: User-defined permissions are always merged with the highest priority. Users can even completely disable a built-in Agent via `disable: true`.

---

In the next section, we will dive deep into the auxiliary functions of Agents -- title generation, summary generation, context compaction, exploratory search, and code generation -- to understand their Prompt designs and invocation patterns.
