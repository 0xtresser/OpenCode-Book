# 16.2 Zed Extension Implementation

> **Model**: claude-opus-4-6 (anthropic/claude-opus-4-6)
> **Generation Date**: 2026-02-18

---

In the previous section, we saw that the VSCode extension adopted a lightweight "terminal + HTTP" integration approach. This section will analyze OpenCode's extension implementation in the Zed editor -- an integration approach fundamentally different from VSCode.

## 16.2.1 `packages/extensions/zed/` Configuration

### Introduction to the Zed Editor

> **Extended Explanation -- The Zed Editor**
>
> Zed is a high-performance code editor written in Rust, created by the original team behind the Atom editor (a well-known open-source editor developed by GitHub, discontinued in 2022). Zed's core features include:
>
> - **Extreme Performance**: GPU-accelerated rendering, with startup and response speeds far exceeding Electron applications (VSCode is based on Electron)
> - **Collaboration First**: Built-in real-time collaborative editing functionality
> - **AI Native**: AI Agent capabilities integrated at the architecture level, providing an "Agent Panel" as the AI interaction interface
>
> The biggest difference between Zed and VSCode lies in the extension model. VSCode extensions are **imperative** -- developers write TypeScript/JavaScript code, calling VSCode APIs to register commands, create UI, and handle events. Zed extensions lean more toward being **declarative** -- describing extension capabilities through configuration files, with the Zed runtime responsible for the actual execution logic.

### Zed's Agent Server Mechanism

The Zed editor introduced the concept of "Agent Server" -- it allows external AI Agents to run as "servers," with Zed acting as a "client" communicating through a standardized protocol. This is exactly the application scenario for ACP (Agent Client Protocol):

```
┌───────────────┐          ACP          ┌──────────────────┐
│  Zed Editor    │ <── Protocol Comm ──> │  OpenCode Agent  │
│  (ACP Client)  │                      │  (ACP Server)    │
│               │                      │                  │
│  Agent Panel   │                      │  opencode acp    │
└───────────────┘                      └──────────────────┘
```

When a user installs the OpenCode extension in Zed, Zed will:
1. Download the corresponding OpenCode binary for the current operating system and CPU architecture
2. Execute the `opencode acp` command to start OpenCode in ACP mode
3. Interact with OpenCode through the ACP protocol for the full lifecycle

This is fundamentally different from the VSCode extension's "create terminal + HTTP communication" model -- the Zed extension does not require any custom code, and all integration logic is handled through the standardized ACP protocol.

### Directory Structure

OpenCode's Zed extension is located in the `packages/extensions/zed/` directory:

```
packages/extensions/zed/
├── extension.toml     # Extension declaration file (core)
└── icons/
    └── opencode.svg   # Extension icon
```

The entire extension consists of only one configuration file and one icon -- no source code, no build steps, no runtime dependencies.

## 16.2.2 `extension.toml` Declaration Format

Let's analyze the complete contents of `extension.toml` section by section:

```toml
id = "opencode"
name = "OpenCode"
description = "The open source coding agent."
version = "1.1.56"
schema_version = 1
authors = ["Anomaly"]
repository = "https://github.com/anomalyco/opencode"

[agent_servers.opencode]
name = "OpenCode"
icon = "./icons/opencode.svg"

[agent_servers.opencode.targets.darwin-aarch64]
archive = "https://github.com/anomalyco/opencode/releases/download/v1.1.56/opencode-darwin-arm64.zip"
cmd = "./opencode"
args = ["acp"]

[agent_servers.opencode.targets.darwin-x86_64]
archive = "https://github.com/anomalyco/opencode/releases/download/v1.1.56/opencode-darwin-x64.zip"
cmd = "./opencode"
args = ["acp"]

[agent_servers.opencode.targets.linux-aarch64]
archive = "https://github.com/anomalyco/opencode/releases/download/v1.1.56/opencode-linux-arm64.tar.gz"
cmd = "./opencode"
args = ["acp"]

[agent_servers.opencode.targets.linux-x86_64]
archive = "https://github.com/anomalyco/opencode/releases/download/v1.1.56/opencode-linux-x64.tar.gz"
cmd = "./opencode"
args = ["acp"]

[agent_servers.opencode.targets.windows-x86_64]
archive = "https://github.com/anomalyco/opencode/releases/download/v1.1.56/opencode-windows-x64.zip"
cmd = "./opencode.exe"
args = ["acp"]
```

### Metadata Section

```toml
id = "opencode"
name = "OpenCode"
description = "The open source coding agent."
version = "1.1.56"
schema_version = 1
authors = ["Anomaly"]
repository = "https://github.com/anomalyco/opencode"
```

These fields are the standard metadata for Zed extensions:

| Field | Meaning |
|-------|---------|
| `id` | Extension unique identifier, must be unique in the Zed extension registry |
| `name` | Display name |
| `version` | Version number, synchronized with the OpenCode main version |
| `schema_version` | TOML configuration format version, currently 1 |
| `authors` | Author list |
| `repository` | Source code repository URL |

### Agent Server Declaration

```toml
[agent_servers.opencode]
name = "OpenCode"
icon = "./icons/opencode.svg"
```

`agent_servers` is the key section in Zed extension TOML. It declares the list of Agent Servers provided by the extension. An extension can declare multiple Agent Servers, each being an independent AI Agent service. `opencode` is the server identifier, and `name` and `icon` are used for display in Zed's Agent Panel.

### Platform Targets

This is the most interesting part of the entire configuration file:

```toml
[agent_servers.opencode.targets.darwin-aarch64]
archive = "https://github.com/.../opencode-darwin-arm64.zip"
cmd = "./opencode"
args = ["acp"]
```

Each target section defines the build artifact and launch command for a platform:

| Platform Identifier | Operating System | CPU Architecture | Example Devices |
|--------------------|-----------------|-----------------|-----------------|
| `darwin-aarch64` | macOS | ARM64 | Apple M1/M2/M3/M4 Mac |
| `darwin-x86_64` | macOS | x86-64 | Intel Mac |
| `linux-aarch64` | Linux | ARM64 | ARM servers, Raspberry Pi |
| `linux-x86_64` | Linux | x86-64 | Most Linux PCs/servers |
| `windows-x86_64` | Windows | x86-64 | Windows PCs |

Each target contains three fields:

- **`archive`**: Points to the compressed package URL for the corresponding platform on GitHub Releases. Zed will automatically download and extract this file. macOS and Windows use `.zip` format, Linux uses `.tar.gz` format
- **`cmd`**: The command to execute after extraction. Note that Windows uses `./opencode.exe`, while other platforms use `./opencode`
- **`args`**: Arguments passed to the command, uniformly `["acp"]`. This indicates launching OpenCode in ACP protocol mode

> **Extended Explanation -- Cross-Platform Binary Distribution**
>
> Why is it necessary to provide separate binary files for each platform? This relates to the fundamental characteristics of compiled languages:
>
> - **Operating System Differences**: Different operating systems have different executable file formats -- macOS uses Mach-O, Linux uses ELF, and Windows uses PE/COFF. Binary files compiled from the same source code cannot run across operating systems.
> - **CPU Architecture Differences**: x86-64 (also known as AMD64) and ARM64 (also known as AArch64) use different instruction sets. Even on the same operating system, programs compiled for x86 cannot run directly on ARM CPUs (Apple's Rosetta 2 is an exception -- it performs real-time translation of x86 programs on M-series Macs).
>
> OpenCode is built with Bun (a JavaScript runtime based on JavaScriptCore), and Bun itself is a compiled application, so separate binary packages must be built for each target platform. GitHub Actions' Matrix Build feature can automate this process -- simultaneously building for all target platforms in the CI/CD pipeline and publishing to GitHub Releases.

### `opencode acp`: ACP Mode

The `args` for all platform targets are `["acp"]`. This means the complete command Zed executes when starting OpenCode is:

```bash
./opencode acp
```

This command starts OpenCode's ACP server mode -- it does not display the TUI interface, but instead communicates with the ACP client (i.e., Zed) through standard input/output (stdin/stdout) using JSON-RPC style protocol communication. This is similar to how Language Server Protocol (LSP) works -- the editor starts a language server process and communicates bidirectionally via stdio.

## 16.2.3 Comparison of VSCode and Zed Extension Approaches

| Dimension | VSCode Extension | Zed Extension |
|-----------|-----------------|---------------|
| **Code Volume** | 138 lines of TypeScript | 0 lines of code (pure configuration) |
| **Integration Method** | Terminal + HTTP | ACP Protocol (stdio) |
| **UI Approach** | Reuses VSCode terminal to display TUI | Uses Zed's native Agent Panel |
| **Communication Direction** | Unidirectional (Extension -> TUI) | Bidirectional (Zed <-> OpenCode) |
| **Installation Method** | VSCode Marketplace | Zed auto-downloads platform binary |
| **Flexibility** | High (can write custom logic) | Low (declarative configuration only) |
| **Feature Depth** | Shallow (file path passing only) | Deep (full Session, permissions, tool calls) |

> **Extended Explanation -- Declarative vs. Imperative Extension Models**
>
> These two extension approaches embody a classic design tradeoff in software engineering:
>
> - **Imperative**: Developers write code describing "how to do it." VSCode extensions are a prime example -- you call `vscode.commands.registerCommand()` to register commands, call `vscode.window.createTerminal()` to create terminals, and every step is an explicit instruction. The advantage is extremely high flexibility; the downside is needing to understand the host API.
>
> - **Declarative**: Developers write configuration describing "what you want." Zed's `extension.toml` is a prime example -- you only need to declare "I have an Agent Server, here's where its binaries are for each platform, and here's the launch command," and Zed handles all the details of downloading, extracting, launching, and communicating. The advantage is simplicity and reliability; the downside is being limited to what the framework supports.
>
> The success of the declarative model depends on the generality of the underlying protocol -- if the ACP protocol is powerful enough, then the declarative Zed extension can achieve functionality equal to or even greater than the imperative VSCode extension. This is also why the design of the ACP protocol is so important.

From the comparison above, it is clear that while Zed's integration approach is "zero-code," its feature depth far exceeds the VSCode extension. This is not the Zed extension's own achievement, but rather because the ACP protocol provides a complete set of Agent interaction standards -- including Session management, permission approval, tool call tracking, streaming message transmission, and more.

In the next section, we will deeply analyze the implementation details of the ACP protocol, understanding how OpenCode implements a complete ACP Agent server through the three files `acp/agent.ts`, `acp/session.ts`, and `acp/types.ts`.
