# 16.1 VSCode 扩展实现

> **模型**: claude-opus-4-6 (anthropic/claude-opus-4-6)  
> **生成日期**: 2026-02-18

---

OpenCode 作为一个终端原生的 AI 编程助手，其核心交互界面是 TUI（Terminal User Interface）。但现代开发者的大部分时间都在 IDE 中度过，因此 OpenCode 需要一种方式将自身"嵌入"到 IDE 的工作流中。VSCode 扩展是 OpenCode 实现 IDE 集成的第一种方式，也是最轻量级的一种。

本节将完整剖析 `sdks/vscode/` 目录下的 VSCode 扩展实现。读者将会发现，这个扩展的设计哲学与常见的 VSCode 扩展截然不同——它不实现语言服务器（Language Server），不嵌入 WebView 面板，甚至不直接与 LLM 通信。它的全部功能可以用一句话概括：**创建一个终端，运行 `opencode` 命令，然后通过 HTTP 与 TUI 通信**。

## 16.1.1 `sdks/vscode/` 架构概述

### 目录结构

OpenCode 的 VSCode 扩展位于仓库的 `sdks/vscode/` 目录下，整个扩展只有一个核心源文件：

```
sdks/vscode/
├── src/
│   └── extension.ts          # 全部扩展逻辑（138 行）
├── images/
│   ├── icon.png              # 扩展图标
│   ├── button-dark.svg       # 深色主题按钮图标
│   └── button-light.svg      # 浅色主题按钮图标
├── package.json              # 扩展清单
├── tsconfig.json             # TypeScript 配置
└── esbuild.js                # 构建脚本
```

是的，你没看错——整个扩展的核心逻辑只有 **138 行 TypeScript 代码**。这不是简陋，而是精心的设计选择。

### 扩展清单 `package.json`

VSCode 扩展的核心配置在 `package.json` 中声明。让我们看看 OpenCode 扩展注册了哪些能力：

```json
{
  "name": "opencode",
  "displayName": "opencode",
  "description": "opencode for VS Code",
  "version": "1.1.56",
  "publisher": "sst-dev",
  "engines": {
    "vscode": "^1.94.0"
  },
  "main": "./dist/extension.js",
  "contributes": {
    "commands": [
      {
        "command": "opencode.openTerminal",
        "title": "Open opencode",
        "icon": {
          "light": "images/button-dark.svg",
          "dark": "images/button-light.svg"
        }
      },
      {
        "command": "opencode.openNewTerminal",
        "title": "Open opencode in new tab",
        "icon": {
          "light": "images/button-dark.svg",
          "dark": "images/button-light.svg"
        }
      },
      {
        "command": "opencode.addFilepathToTerminal",
        "title": "Add Filepath to Terminal"
      }
    ],
    "menus": {
      "editor/title": [
        {
          "command": "opencode.openNewTerminal",
          "group": "navigation"
        }
      ]
    },
    "keybindings": [
      {
        "command": "opencode.openTerminal",
        "key": "cmd+escape",
        "mac": "cmd+escape",
        "win": "ctrl+escape",
        "linux": "ctrl+escape"
      },
      {
        "command": "opencode.openNewTerminal",
        "key": "cmd+shift+escape",
        "mac": "cmd+shift+escape",
        "win": "ctrl+shift+escape",
        "linux": "ctrl+shift+escape"
      },
      {
        "command": "opencode.addFilepathToTerminal",
        "key": "cmd+alt+k",
        "mac": "cmd+alt+k",
        "win": "ctrl+alt+K",
        "linux": "ctrl+alt+K"
      }
    ]
  }
}
```

从这个配置中可以提炼出以下关键信息：

| 命令 | 快捷键 | 功能 |
|------|--------|------|
| `opencode.openTerminal` | `Cmd+Escape` | 打开/聚焦 OpenCode 终端 |
| `opencode.openNewTerminal` | `Cmd+Shift+Escape` | 在新标签页打开 OpenCode |
| `opencode.addFilepathToTerminal` | `Cmd+Alt+K` | 将当前文件路径发送到终端 |

注意 `menus.editor/title` 配置——`openNewTerminal` 命令被放在了编辑器标题栏的导航组中，这意味着用户可以在编辑器右上角看到一个 OpenCode 按钮。

### 设计哲学：终端即界面

大多数 AI 编程助手的 VSCode 扩展会选择以下一种或多种集成方式：

1. **WebView 面板**：在侧边栏嵌入一个完整的 Web 界面（如 GitHub Copilot Chat）
2. **Language Server Protocol (LSP)**：通过 LSP 提供补全、诊断等功能
3. **内联建议**：在编辑器中直接显示 AI 建议（如 Copilot 的 Ghost Text）

OpenCode 的扩展选择了一条完全不同的路：**复用 VSCode 内置终端**。这个决策背后的逻辑是：

- OpenCode 本身就是一个功能完备的 TUI 应用，拥有丰富的交互界面
- TUI 已经处理了所有复杂的 UI 逻辑（消息显示、工具调用进度、权限确认等）
- 在 VSCode 终端中运行 OpenCode 与在独立终端中运行体验完全一致
- 扩展的复杂度极低，维护成本几乎为零

> **衍生解释——VSCode Extension API 生命周期**
>
> VSCode 扩展有两个核心生命周期函数：
> - `activate(context)`：扩展被激活时调用。VSCode 会根据 `activationEvents` 配置决定何时激活扩展。如果 `activationEvents` 为空数组（如 OpenCode），则在 VSCode 启动时立即激活。
> - `deactivate()`：扩展被停用时调用，用于清理资源。
>
> `context.subscriptions` 是一个 Disposable 数组，用于注册需要在扩展停用时自动清理的资源。将 command handler 推入其中可以确保扩展卸载时命令绑定被正确移除。

## 16.1.2 与 OpenCode Server 的通信

### 基于 HTTP 的终端通信架构

OpenCode VSCode 扩展的通信架构可以用以下图示表达：

```
┌─────────────────────────────────────────────────┐
│                   VSCode                         │
│                                                  │
│  ┌──────────────┐         ┌──────────────────┐  │
│  │  Extension    │──HTTP──>│  VSCode Terminal  │  │
│  │  (TypeScript) │         │  (opencode TUI)   │  │
│  │              │<──poll──│  port: 随机端口    │  │
│  └──────────────┘         └──────────────────┘  │
│         │                         │              │
│         │ registerCommand()       │ sendText()   │
│         ▼                         ▼              │
│  ┌──────────────┐         ┌──────────────────┐  │
│  │  Command      │         │  OpenCode 进程    │  │
│  │  Palette      │         │  HTTP Server      │  │
│  │  Keybindings  │         │  /tui/append-prompt│  │
│  └──────────────┘         └──────────────────┘  │
└─────────────────────────────────────────────────┘
```

核心通信流程如下：

1. **扩展创建终端**，在终端环境变量中注入随机端口号
2. **终端执行 `opencode --port <port>`**，OpenCode 启动 TUI 并在指定端口开启 HTTP 服务器
3. **扩展轮询健康检查端点** `http://localhost:<port>/app`，确认 TUI 已就绪
4. **后续通信** 通过 `POST http://localhost:<port>/tui/append-prompt` 发送内容

### 端口选择策略

```typescript
const port = Math.floor(Math.random() * (65535 - 16384 + 1)) + 16384
```

扩展使用随机端口号，范围是 16384 到 65535。这是 IANA（Internet Assigned Numbers Authority）定义的**动态/私有端口范围**（也称为 ephemeral ports），避免与系统服务和已知应用的端口冲突。

> **衍生解释——端口号分配**
>
> TCP/UDP 端口号范围为 0-65535，分为三段：
> - **0-1023**：系统/特权端口（Well-Known Ports），需要 root 权限，如 HTTP(80)、HTTPS(443)、SSH(22)
> - **1024-49151**：注册端口（Registered Ports），分配给特定服务，如 MySQL(3306)、PostgreSQL(5432)
> - **49152-65535**：动态/私有端口（Dynamic/Ephemeral Ports），可自由使用
>
> OpenCode 选择 16384-65535 范围稍微激进（包含了部分注册端口区域），但在实际使用中冲突概率极低。操作系统的 TCP 栈也会阻止绑定已被占用的端口。

### 就绪检测机制

OpenCode TUI 启动需要时间（加载配置、初始化子系统等），扩展不能立即发送请求。轮询机制解决了这个问题：

```typescript
let tries = 10
let connected = false
do {
  await new Promise((resolve) => setTimeout(resolve, 200))
  try {
    await fetch(`http://localhost:${port}/app`)
    connected = true
    break
  } catch (e) {}
  tries--
} while (tries > 0)
```

策略很简单：每 200 毫秒尝试一次，最多 10 次（总计最多等待 2 秒）。如果 2 秒内 OpenCode 没有就绪，就放弃初始文件路径的注入（终端本身仍然可用，用户可以手动输入）。

### `appendPrompt`：轻量级 IPC

```typescript
async function appendPrompt(port: number, text: string) {
  await fetch(`http://localhost:${port}/tui/append-prompt`, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
    },
    body: JSON.stringify({ text }),
  })
}
```

这是整个通信机制中最关键的函数。它向 OpenCode TUI 的 HTTP 端点发送一个 POST 请求，请求体是一个简单的 JSON 对象 `{ text: "..." }`。TUI 收到后会将文本追加到当前输入框中（而不是直接提交），用户仍然可以编辑或补充内容后再发送。

> **衍生解释——进程间通信（IPC）**
>
> 进程间通信（Inter-Process Communication, IPC）是操作系统中不同进程之间交换数据的机制。常见的 IPC 方式包括：
>
> | 方式 | 特点 | 适用场景 |
> |------|------|----------|
> | 管道（Pipe）| 单向，父子进程 | 简单数据流 |
> | 套接字（Socket）| 双向，跨网络 | 网络通信 |
> | 共享内存 | 最快，需同步 | 大量数据交换 |
> | HTTP/REST | 标准化，跨语言 | 松耦合服务 |
> | WebSocket | 双向实时 | 推送通知 |
>
> OpenCode 选择 HTTP 而非 WebSocket 或 Unix Socket，原因在于：
> 1. 通信是单向的（扩展 → TUI），不需要 TUI 主动推送给扩展
> 2. HTTP 是最简单、调试最方便的协议
> 3. `fetch` API 在所有 JavaScript 运行时中都可用

## 16.1.3 核心功能实现

让我们逐一分析扩展注册的三个命令。

### 命令一：`opencode.openTerminal`——打开或聚焦终端

```typescript
let openTerminalDisposable = vscode.commands.registerCommand(
  "opencode.openTerminal",
  async () => {
    // 检查是否已存在名为 "opencode" 的终端
    const existingTerminal = vscode.window.terminals.find(
      (t) => t.name === TERMINAL_NAME
    )
    if (existingTerminal) {
      existingTerminal.show()
      return
    }

    await openTerminal()
  }
)
```

这个命令实现了**幂等性**——如果已经存在一个 OpenCode 终端，就直接聚焦它；否则创建新的。这是用户最常用的命令，绑定到 `Cmd+Escape`，形成了一种"快速切换"的交互模式：按一次切到 OpenCode，再按一次回到编辑器。

### 命令二：`opencode.openNewTerminal`——强制打开新终端

```typescript
let openNewTerminalDisposable = vscode.commands.registerCommand(
  "opencode.openNewTerminal",
  async () => {
    await openTerminal()
  }
)
```

直接调用 `openTerminal()` 创建新实例。用户可能需要同时运行多个 OpenCode 实例处理不同任务。

### 核心函数：`openTerminal()`

```typescript
async function openTerminal() {
  const port = Math.floor(Math.random() * (65535 - 16384 + 1)) + 16384
  const terminal = vscode.window.createTerminal({
    name: TERMINAL_NAME,
    iconPath: {
      light: vscode.Uri.file(context.asAbsolutePath("images/button-dark.svg")),
      dark: vscode.Uri.file(context.asAbsolutePath("images/button-light.svg")),
    },
    location: {
      viewColumn: vscode.ViewColumn.Beside,
      preserveFocus: false,
    },
    env: {
      _EXTENSION_OPENCODE_PORT: port.toString(),
      OPENCODE_CALLER: "vscode",
    },
  })

  terminal.show()
  terminal.sendText(`opencode --port ${port}`)

  // ... 就绪检测和初始文件路径注入 ...
}
```

这个函数的几个关键设计：

1. **终端位置**：`viewColumn: vscode.ViewColumn.Beside` 表示在编辑器旁边的分屏中打开，而不是底部面板。这让用户可以同时看到代码和 OpenCode 的输出。

2. **环境变量注入**：
   - `_EXTENSION_OPENCODE_PORT`：将随机端口号传递给终端环境，以便后续 `addFilepathToTerminal` 命令能够找到正确的通信端口
   - `OPENCODE_CALLER: "vscode"`：告知 OpenCode 它是从 VSCode 扩展启动的，OpenCode 内部可以据此调整行为

3. **`sendText` 启动 OpenCode**：`terminal.sendText(\`opencode --port ${port}\`)` 向终端发送命令文本，就像用户手动输入一样。这比使用 `shellPath`/`shellArgs` 更灵活，因为 OpenCode 运行在用户的 shell 环境中，可以继承 `PATH`、shell 配置等。

4. **初始文件路径注入**：创建终端后，如果当前编辑器有打开的文件，会自动将文件路径发送给 OpenCode，形成"在当前文件上下文中开始对话"的体验：

```typescript
const fileRef = getActiveFile()
if (!fileRef) {
  return
}

// 等待 TUI 就绪
let tries = 10
let connected = false
do {
  await new Promise((resolve) => setTimeout(resolve, 200))
  try {
    await fetch(`http://localhost:${port}/app`)
    connected = true
    break
  } catch (e) {}
  tries--
} while (tries > 0)

if (connected) {
  await appendPrompt(port, `In ${fileRef}`)
  terminal.show()
}
```

### 命令三：`opencode.addFilepathToTerminal`——发送文件路径

这是最有意思的命令，它在 VSCode 编辑器和 OpenCode 终端之间建立了上下文桥梁：

```typescript
let addFilepathDisposable = vscode.commands.registerCommand(
  "opencode.addFilepathToTerminal",
  async () => {
    const fileRef = getActiveFile()
    if (!fileRef) {
      return
    }

    const terminal = vscode.window.activeTerminal
    if (!terminal) {
      return
    }

    if (terminal.name === TERMINAL_NAME) {
      // @ts-ignore
      const port = terminal.creationOptions.env?.["_EXTENSION_OPENCODE_PORT"]
      port
        ? await appendPrompt(parseInt(port), fileRef)
        : terminal.sendText(fileRef, false)
      terminal.show()
    }
  }
)
```

这里有一个优雅的降级策略：
- 如果能获取到端口号（通过 `creationOptions.env`），就用 HTTP 将文件路径追加到输入框
- 如果获取不到（比如终端是用户手动创建的），就用 `sendText(fileRef, false)` 直接向终端发送文本（第二个参数 `false` 表示不自动按回车）

注意 `@ts-ignore` 注释——`creationOptions.env` 在 VSCode 类型定义中可能不是公开 API，OpenCode 团队选择通过类型检查忽略来访问它。这是一种务实但有风险的做法。

### `getActiveFile()`：智能文件引用生成

```typescript
function getActiveFile() {
  const activeEditor = vscode.window.activeTextEditor
  if (!activeEditor) {
    return
  }

  const document = activeEditor.document
  const workspaceFolder = vscode.workspace.getWorkspaceFolder(document.uri)
  if (!workspaceFolder) {
    return
  }

  // 获取相对于工作区根目录的路径
  const relativePath = vscode.workspace.asRelativePath(document.uri)
  let filepathWithAt = `@${relativePath}`

  // 检查是否有选中区域并添加行号
  const selection = activeEditor.selection
  if (!selection.isEmpty) {
    const startLine = selection.start.line + 1  // 转换为 1-based 行号
    const endLine = selection.end.line + 1

    if (startLine === endLine) {
      filepathWithAt += `#L${startLine}`      // 单行选中
    } else {
      filepathWithAt += `#L${startLine}-${endLine}`  // 多行选中
    }
  }

  return filepathWithAt
}
```

这个函数生成的文件引用格式与 GitHub 的文件行号链接格式一致：
- `@src/index.ts` —— 引用整个文件
- `@src/index.ts#L42` —— 引用第 42 行
- `@src/index.ts#L10-25` —— 引用第 10-25 行

这种 `@` 前缀格式是 OpenCode 的"at-mention"语法——在 prompt 中使用 `@path/to/file` 可以让 OpenCode 自动读取并将文件内容作为上下文注入对话。这样，用户按 `Cmd+Alt+K` 后，当前编辑的文件就自动成为了 AI 对话的上下文。

## 16.1.4 小结

OpenCode 的 VSCode 扩展是一个极简主义的 IDE 集成方案。它的全部源码只有 138 行，却实现了三个核心功能：终端管理、HTTP 通信和上下文传递。这种"终端即界面"的设计理念有几个值得学习的地方：

1. **最小复杂度原则**：不在扩展层重复实现 TUI 已有的功能
2. **松耦合架构**：扩展和 OpenCode 进程通过 HTTP 通信，互不依赖
3. **优雅降级**：HTTP 不可用时回退到 `sendText`
4. **环境变量桥接**：通过 `_EXTENSION_OPENCODE_PORT` 在进程间传递端口信息

但这种方案也有明显的局限性——它无法实现 IDE 内的内联代码建议、实时诊断、代码操作等深度集成功能。这些能力需要更强大的协议支持，这正是 Zed 扩展和 ACP 协议要解决的问题。

下一节我们将看到 Zed 编辑器采取了一种完全不同的集成方式——声明式配置加 ACP 协议通信。
