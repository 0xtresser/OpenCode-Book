# 12.1 CLI 启动流程

> **模型**: claude-opus-4-6 (anthropic/claude-opus-4-6)  
> **生成日期**: 2026-02-17

---

前面十一章我们深入剖析了 OpenCode 的内核——Session、Tool、Agent、Provider、MCP、权限、快照、事件总线等模块。这些模块构成了"引擎"，但用户并不直接与引擎交互——他们通过**命令行界面（CLI）**与 OpenCode 对话。本章将从用户交互的角度，解析 OpenCode 的前端实现。

## 12.1.1 入口文件 index.ts

OpenCode 的 CLI 入口文件是 `packages/opencode/src/index.ts`，它使用 **yargs** 框架来处理命令行参数和子命令分发：

```typescript
// index.ts
import yargs from "yargs"
import { hideBin } from "yargs/helpers"

const cli = yargs(hideBin(process.argv))
  .parserConfiguration({ "populate--": true })
  .scriptName("opencode")
  .wrap(100)
  .help("help", "show help").alias("help", "h")
  .version("version", "show version number", Installation.VERSION)
  .alias("version", "v")
  .option("print-logs", { describe: "print logs to stderr", type: "boolean" })
  .option("log-level", {
    describe: "log level",
    type: "string",
    choices: ["DEBUG", "INFO", "WARN", "ERROR"],
  })
  .middleware(async (opts) => {
    // 全局中间件：初始化日志系统
    await Log.init({
      print: process.argv.includes("--print-logs"),
      dev: Installation.isLocal(),
      level: opts.logLevel ?? (Installation.isLocal() ? "DEBUG" : "INFO"),
    })

    // 设置环境变量标识
    process.env.AGENT = "1"
    process.env.OPENCODE = "1"
  })
  .usage("\n" + UI.logo())
  // 注册所有子命令
  .command(TuiThreadCommand)    // 默认命令 $0
  .command(RunCommand)           // opencode run
  .command(ServeCommand)         // opencode serve
  .command(WebCommand)           // opencode web
  .command(AuthCommand)          // opencode auth
  .command(McpCommand)           // opencode mcp
  .command(ModelsCommand)        // opencode models
  .command(SessionCommand)       // opencode session
  .command(ExportCommand)        // opencode export
  .command(ImportCommand)        // opencode import
  .command(GenerateCommand)      // opencode generate
  .command(GithubCommand)        // opencode github
  .command(PrCommand)            // opencode pr
  .command(StatsCommand)         // opencode stats
  .command(UpgradeCommand)       // opencode upgrade
  .command(UninstallCommand)     // opencode uninstall
  .command(AcpCommand)           // opencode acp
  .command(AgentCommand)         // opencode agent
  .command(AttachCommand)        // opencode attach
  .strict()

await cli.parse()
```

> **衍生解释：yargs 是什么？**
>
> yargs 是 Node.js 生态中最流行的命令行参数解析库之一。它提供了：
> - 子命令（subcommand）系统
> - 参数类型验证
> - 自动生成帮助文档
> - Shell 自动补全脚本生成
> - 中间件（middleware）支持
>
> OpenCode 使用 `"populate--": true` 配置，允许 `--` 后的参数被收集到 `args["--"]` 数组中——这在 `opencode run` 命令中用于将额外参数传递给 Shell 命令。

几个值得注意的设计点：

1. **`TuiThreadCommand` 使用 `$0` 命令名**：这意味着当用户直接运行 `opencode` 而不带子命令时，默认启动 TUI 交互界面。
2. **全局中间件（middleware）**：所有子命令执行前都会先初始化日志系统。这确保了即使子命令执行失败，错误日志也能被正确记录。
3. **`process.env.AGENT = "1"`**：设置环境变量标识，让子进程（如通过 `bash` 工具启动的 Shell）知道自己运行在 OpenCode 环境中。

## 12.1.2 cli/bootstrap.ts——Instance 上下文引导

大多数子命令在执行前需要初始化 OpenCode 的 Instance 上下文（加载配置、连接存储、初始化模块等）。`bootstrap()` 函数封装了这个过程：

```typescript
// cli/bootstrap.ts
export async function bootstrap<T>(directory: string, cb: () => Promise<T>) {
  return Instance.provide({
    directory,
    init: InstanceBootstrap,
    fn: async () => {
      try {
        const result = await cb()
        return result
      } finally {
        await Instance.dispose()
      }
    },
  })
}
```

`bootstrap()` 做了三件事：

1. **`Instance.provide()`**：在指定目录下创建 Instance 上下文，执行 `InstanceBootstrap` 初始化函数（加载项目配置、检测 Git 信息、启动文件监控等）。
2. **执行回调**：在 Instance 上下文中执行具体的命令逻辑。
3. **清理资源**：无论命令成功还是失败（`finally`），都调用 `Instance.dispose()` 清理资源（关闭文件监控、清除定时器、断开 MCP 连接等）。

这种"获取上下文 → 执行 → 清理"的模式类似于数据库连接的使用方式——确保资源不会泄漏。

## 12.1.3 cli/cmd/cmd.ts——子命令注册

每个子命令都是一个 yargs `CommandModule`，OpenCode 提供了一个简单的类型包装器：

```typescript
// cli/cmd/cmd.ts
type WithDoubleDash<T> = T & { "--"?: string[] }

export function cmd<T, U>(input: CommandModule<T, WithDoubleDash<U>>) {
  return input
}
```

`cmd()` 函数的唯一作用是添加 `"--"` 参数的类型定义。每个子命令按以下模式定义：

```typescript
export const MyCommand = cmd({
  command: "mycommand [args]",     // 命令名和位置参数
  describe: "description text",     // 帮助文档描述
  builder: (yargs) => yargs         // 参数定义
    .option("flag", { type: "boolean" }),
  handler: async (args) => {        // 命令处理函数
    // 执行逻辑
  },
})
```

## 12.1.4 各子命令概览

以下是 OpenCode 注册的全部 19 个子命令：

| 命令 | 文件 | 功能 |
|------|------|------|
| `$0` (默认) | `tui/thread.ts` | 启动 TUI 交互界面 |
| `run` | `run.ts` | 执行单次提示词（非交互） |
| `serve` | `serve.ts` | 启动无头 HTTP Server |
| `web` | `web.ts` | 启动 Server 并打开 Web UI |
| `auth` | `auth.ts` | 管理认证凭据 |
| `mcp` | `mcp.ts` | MCP Server 管理 |
| `models` | `models.ts` | 列出可用模型 |
| `session` | `session.ts` | 会话管理 |
| `export` | `export.ts` | 导出会话数据 |
| `import` | `import.ts` | 导入会话数据 |
| `generate` | `generate.ts` | 生成 OpenAPI 规范 |
| `github` | `github.ts` | GitHub 集成 |
| `pr` | `pr.ts` | Pull Request 操作 |
| `stats` | `stats.ts` | 使用统计 |
| `upgrade` | `upgrade.ts` | 版本升级 |
| `uninstall` | `uninstall.ts` | 卸载清理 |
| `acp` | `acp.ts` | Agent Client Protocol |
| `agent` | `agent.ts` | Agent 管理 |
| `attach` | `tui/attach.ts` | 连接到已运行的 Server |

这些命令可以按功能分为四组：

- **交互式**：`$0`（TUI）、`attach`、`web`
- **执行式**：`run`、`pr`、`github`
- **管理式**：`auth`、`mcp`、`models`、`session`、`agent`、`export`、`import`、`stats`
- **基础设施**：`serve`、`generate`、`upgrade`、`uninstall`、`acp`

## 12.1.5 错误处理

入口文件的 `try/catch/finally` 块处理了所有未捕获的错误：

```typescript
try {
  await cli.parse()
} catch (e) {
  // 收集错误信息
  let data: Record<string, any> = {}
  if (e instanceof NamedError) {
    Object.assign(data, e.toObject().data)
  }
  if (e instanceof Error) {
    Object.assign(data, { name: e.name, message: e.message, stack: e.stack })
  }

  // 记录到日志
  Log.Default.error("fatal", data)

  // 格式化并显示给用户
  const formatted = FormatError(e)
  if (formatted) UI.error(formatted)
  if (formatted === undefined) {
    UI.error("Unexpected error, check log file at " + Log.file() + " for more details")
  }

  process.exitCode = 1
} finally {
  // 显式退出，避免子进程挂起
  process.exit()
}
```

`FormatError()` 函数（定义在 `cli/error.ts`）会识别特定类型的错误并生成用户友好的错误信息：

- **MCP Server 失败**：显示哪个 MCP Server 启动失败以及原因。
- **模型未找到**：显示用户指定的模型名称和建议的替代模型。
- **Provider 初始化失败**：显示哪个 Provider 初始化失败。
- **配置文件错误**：显示配置文件路径和解析错误的具体位置。

最后的 `process.exit()` 是一个特别的设计决策——注释说明这是为了确保某些不响应 SIGTERM 信号的子进程（如 Docker 容器中的 MCP Server）能被正确终止。
