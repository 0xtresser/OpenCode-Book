# 15.2 插件入口与初始化

> **模型**: claude-opus-4-6 (anthropic/claude-opus-4-6)  
> **生成日期**: 2026-02-17

---

上一节我们概览了 oh-my-opencode 的整体架构和功能特性。本节将深入其初始化过程——从 OpenCode 调用 Plugin 入口函数开始，到配置加载、Manager 创建、工具注册、Hook 创建、最终接口组装的完整链路。

## 15.2.1 `src/index.ts` —— Plugin 入口

oh-my-opencode 的入口文件出奇的简洁。整个文件只有约 100 行，但它精确地编排了整个初始化流程：

```typescript
// oh-my-opencode/src/index.ts
import type { Plugin } from "@opencode-ai/plugin"

const OhMyOpenCodePlugin: Plugin = async (ctx) => {
  log("[OhMyOpenCodePlugin] ENTRY - plugin loading", {
    directory: ctx.directory,
  })

  // 步骤 0：基础环境准备
  injectServerAuthIntoClient(ctx.client)
  startTmuxCheck()

  // 步骤 1：加载配置
  const pluginConfig = loadPluginConfig(ctx.directory, ctx)
  const disabledHooks = new Set(pluginConfig.disabled_hooks ?? [])
  const isHookEnabled = (hookName: HookName): boolean => !disabledHooks.has(hookName)
  const safeHookEnabled = pluginConfig.experimental?.safe_hook_creation ?? true

  // 步骤 2：创建辅助状态
  const firstMessageVariantGate = createFirstMessageVariantGate()
  const tmuxConfig = {
    enabled: pluginConfig.tmux?.enabled ?? false,
    layout: pluginConfig.tmux?.layout ?? "main-vertical",
    main_pane_size: pluginConfig.tmux?.main_pane_size ?? 60,
    // ...
  }
  const modelCacheState = createModelCacheState()

  // 步骤 3：创建 Manager
  const managers = createManagers({
    ctx, pluginConfig, tmuxConfig, modelCacheState,
    backgroundNotificationHookEnabled: isHookEnabled("background-notification"),
  })

  // 步骤 4：创建工具（异步）
  const toolsResult = await createTools({ ctx, pluginConfig, managers })

  // 步骤 5：创建 Hook
  const hooks = createHooks({
    ctx, pluginConfig, modelCacheState,
    backgroundManager: managers.backgroundManager,
    isHookEnabled, safeHookEnabled,
    mergedSkills: toolsResult.mergedSkills,
    availableSkills: toolsResult.availableSkills,
  })

  // 步骤 6：组装 Plugin 接口
  const pluginInterface = createPluginInterface({
    ctx, pluginConfig, firstMessageVariantGate,
    managers, hooks, tools: toolsResult.filteredTools,
  })

  // 步骤 7：返回最终接口（附加 compaction 处理）
  return {
    ...pluginInterface,
    "experimental.session.compacting": async (_input, output) => {
      await hooks.compactionTodoPreserver?.capture(_input.sessionID)
      await hooks.claudeCodeHooks?.["experimental.session.compacting"]?.(_input, output)
      if (hooks.compactionContextInjector) {
        output.context.push(hooks.compactionContextInjector(_input.sessionID))
      }
    },
  }
}

export default OhMyOpenCodePlugin
```

### 三大初始化步骤

入口函数的核心逻辑被分解为三个工厂函数：

**`createManagers()`** —— 创建长生命周期的管理器实例：

```typescript
// oh-my-opencode/src/create-managers.ts
export function createManagers(args): Managers {
  // TmuxSessionManager：管理 tmux 窗格的创建、布局和清理
  const tmuxSessionManager = new TmuxSessionManager(ctx, tmuxConfig)

  // BackgroundManager：管理后台 Agent 的创建、轮询和并发控制
  const backgroundManager = new BackgroundManager(ctx, pluginConfig.background_task, {
    tmuxConfig,
    onSubagentSessionCreated: async (event) => {
      // 当后台子 Agent 创建会话时，通知 tmux 管理器
      await tmuxSessionManager.onSessionCreated({ /* ... */ })
    },
    onShutdown: () => {
      // 关闭时清理 tmux 资源
      tmuxSessionManager.cleanup().catch(/* ... */)
    },
    enableParentSessionNotifications: backgroundNotificationHookEnabled,
  })

  // 初始化 Toast 通知管理器
  initTaskToastManager(ctx.client)

  // SkillMcpManager：管理 Skill 内嵌 MCP 服务的生命周期
  const skillMcpManager = new SkillMcpManager()

  // ConfigHandler：处理运行时配置查询
  const configHandler = createConfigHandler({
    ctx: { directory: ctx.directory, client: ctx.client },
    pluginConfig, modelCacheState,
  })

  return { tmuxSessionManager, backgroundManager, skillMcpManager, configHandler }
}
```

这里有一个值得注意的设计：`BackgroundManager` 接收了一个 `onSubagentSessionCreated` 回调。这实现了后台 Agent 系统和 tmux 可视化系统之间的**松耦合**——当一个后台子 Agent 被创建时，tmux 管理器会自动为它分配一个新的终端窗格，让用户可以实时观察子 Agent 的工作状态。

**`createTools()`** —— 注册所有自定义工具：

```typescript
// oh-my-opencode/src/create-tools.ts
export async function createTools(args): Promise<CreateToolsResult> {
  // 加载 Skill 上下文（用户安装的 Skill 文件）
  const skillContext = await createSkillContext({
    directory: ctx.directory,
    pluginConfig,
  })

  // 创建 Category 列表（用于 task 工具的 category 参数）
  const availableCategories = createAvailableCategories(pluginConfig)

  // 注册所有工具到工具表
  const { filteredTools, taskSystemEnabled } = createToolRegistry({
    ctx, pluginConfig, managers,
    skillContext, availableCategories,
  })

  return {
    filteredTools,
    mergedSkills: skillContext.mergedSkills,
    availableSkills: skillContext.availableSkills,
    availableCategories,
    browserProvider: skillContext.browserProvider,
    disabledSkills: skillContext.disabledSkills,
    taskSystemEnabled,
  }
}
```

注意 `createTools` 是整个初始化链中唯一的 **异步** 步骤（前面有 `await`）。这是因为 Skill 加载需要从文件系统读取 `.md` 文件，涉及 I/O 操作。

**`createHooks()`** —— 创建所有行为 Hook：

```typescript
// oh-my-opencode/src/create-hooks.ts
export function createHooks(args) {
  // 核心 Hook：上下文监控、错误恢复、通知等
  const core = createCoreHooks({
    ctx, pluginConfig, modelCacheState,
    isHookEnabled, safeHookEnabled,
  })

  // 续接 Hook：Ralph Loop、Todo 强制、Start Work 等
  const continuation = createContinuationHooks({
    ctx, pluginConfig, isHookEnabled, safeHookEnabled,
    backgroundManager, sessionRecovery: core.sessionRecovery,
  })

  // Skill Hook：Category-Skill 提醒、Agent 使用提醒等
  const skill = createSkillHooks({
    ctx, isHookEnabled, safeHookEnabled,
    mergedSkills, availableSkills,
  })

  return { ...core, ...continuation, ...skill }
}
```

Hook 被进一步分为三组子工厂：`createCoreHooks()`、`createContinuationHooks()` 和 `createSkillHooks()`。这种分组降低了单个文件的复杂度，同时让每组 Hook 可以共享组内的依赖关系。

### 接口组装

最后，`createPluginInterface()` 将所有准备好的组件映射到 OpenCode Plugin 接口：

```typescript
// oh-my-opencode/src/plugin-interface.ts
export function createPluginInterface(args): PluginInterface {
  return {
    tool: tools,                                    // 自定义工具

    "chat.params": createChatParamsHandler({...}),  // 请求参数注入
    "chat.message": createChatMessageHandler({...}),// 消息预处理
    "experimental.chat.messages.transform":         // 消息列表变换
      createMessagesTransformHandler({...}),

    config: managers.configHandler,                 // 配置处理

    event: createEventHandler({...}),               // 事件处理
    "tool.execute.before": createToolExecuteBeforeHandler({...}), // 工具执行前
    "tool.execute.after": createToolExecuteAfterHandler({...}),   // 工具执行后
  }
}
```

每个接口字段都通过一个专门的 Handler 工厂函数创建，实现了关注点分离。

## 15.2.2 配置加载（`plugin-config.ts`）

oh-my-opencode 有一个灵活的双层配置系统，支持**用户级**和**项目级**配置的合并。

### 配置文件发现

```typescript
// oh-my-opencode/src/plugin-config.ts
export function loadPluginConfig(directory: string, ctx: unknown): OhMyOpenCodeConfig {
  // 用户级配置路径：~/.config/opencode/oh-my-opencode.json[c]
  const configDir = getOpenCodeConfigDir({ binary: "opencode" })
  const userBasePath = path.join(configDir, "oh-my-opencode")
  const userDetected = detectConfigFile(userBasePath)

  // 项目级配置路径：<project>/.opencode/oh-my-opencode.json[c]
  const projectBasePath = path.join(directory, ".opencode", "oh-my-opencode")
  const projectDetected = detectConfigFile(projectBasePath)

  // 先加载用户级配置作为 base
  let config = loadConfigFromPath(userConfigPath, ctx) ?? {}

  // 再用项目级配置 override
  const projectConfig = loadConfigFromPath(projectConfigPath, ctx)
  if (projectConfig) {
    config = mergeConfigs(config, projectConfig)
  }

  return config
}
```

配置查找遵循一个清晰的优先级链：

```
项目级 .opencode/oh-my-opencode.jsonc  (最高优先级)
  ↓ merge
项目级 .opencode/oh-my-opencode.json
  ↓ merge
用户级 ~/.config/opencode/oh-my-opencode.jsonc
  ↓ merge
用户级 ~/.config/opencode/oh-my-opencode.json
  ↓ merge
默认值（Zod Schema 定义）                (最低优先级)
```

### JSONC 支持

oh-my-opencode 使用了 `jsonc-parser` 库来支持 **JSONC（JSON with Comments）** 格式：

```typescript
// oh-my-opencode/src/shared/jsonc-parser.ts
import { parse, ParseError, printParseErrorCode } from "jsonc-parser"

export function parseJsonc<T = unknown>(content: string): T {
  const errors: ParseError[] = []
  const result = parse(content, errors, {
    allowTrailingComma: true,    // 允许尾部逗号
    disallowComments: false,     // 允许注释
  }) as T

  if (errors.length > 0) {
    throw new SyntaxError(`JSONC parse error: ${errorMessages}`)
  }
  return result
}
```

> **衍生解释：什么是 JSONC？**
>
> 标准 JSON 格式不允许注释和尾部逗号。这在配置文件中是一个显著的不便——用户无法在配置项旁边写说明文字。JSONC（JSON with Comments）是微软在 VS Code 中推广的一种扩展格式，它在标准 JSON 的基础上增加了两个特性：
>
> 1. **行注释**：`// 这是注释`
> 2. **块注释**：`/* 这也是注释 */`
> 3. **尾部逗号**：`{ "a": 1, "b": 2, }` 末尾的逗号不会报错
>
> 许多工具都支持 JSONC，包括 VS Code 的 `settings.json`、TypeScript 的 `tsconfig.json` 等。oh-my-opencode 通过 `jsonc-parser` 库实现了对 JSONC 的原生支持。

### 部分配置容错解析

oh-my-opencode 的一个亮点是 **部分配置容错**（Partial Config Parsing）。当配置文件中某个字段不合法时，不会导致整个配置加载失败，而是跳过出错的部分，保留有效的配置：

```typescript
// oh-my-opencode/src/plugin-config.ts
export function parseConfigPartially(
  rawConfig: Record<string, unknown>
): OhMyOpenCodeConfig | null {
  // 先尝试完整解析
  const fullResult = OhMyOpenCodeConfigSchema.safeParse(rawConfig)
  if (fullResult.success) {
    return fullResult.data
  }

  // 完整解析失败 → 逐字段尝试
  const partialConfig: Record<string, unknown> = {}
  const invalidSections: string[] = []

  for (const key of Object.keys(rawConfig)) {
    // 将每个顶级字段单独验证
    const sectionResult = OhMyOpenCodeConfigSchema.safeParse({ [key]: rawConfig[key] })
    if (sectionResult.success) {
      const parsed = sectionResult.data as Record<string, unknown>
      if (parsed[key] !== undefined) {
        partialConfig[key] = parsed[key]
      }
    } else {
      // 记录出错字段但不中断
      invalidSections.push(`${key}: ${sectionErrors}`)
    }
  }

  if (invalidSections.length > 0) {
    log("Partial config loaded — invalid sections skipped:", invalidSections)
  }

  return partialConfig as OhMyOpenCodeConfig
}
```

这个设计的核心思路是：配置文件中 `agents` 字段写错了，不应该影响 `hooks` 和 `tools` 的正常工作。通过逐字段验证，oh-my-opencode 最大限度地保留了有效配置，同时通过日志告知用户哪些部分被跳过了。

### 配置合并策略

双层配置的合并不是简单的覆盖，而是根据字段类型采用不同策略：

```typescript
// oh-my-opencode/src/plugin-config.ts
export function mergeConfigs(
  base: OhMyOpenCodeConfig,
  override: OhMyOpenCodeConfig
): OhMyOpenCodeConfig {
  return {
    ...base,
    ...override,
    // 对象类型字段：深度合并
    agents: deepMerge(base.agents, override.agents),
    categories: deepMerge(base.categories, override.categories),
    claude_code: deepMerge(base.claude_code, override.claude_code),

    // 数组类型字段：去重合并
    disabled_agents: [
      ...new Set([
        ...(base.disabled_agents ?? []),
        ...(override.disabled_agents ?? []),
      ]),
    ],
    disabled_hooks: [
      ...new Set([
        ...(base.disabled_hooks ?? []),
        ...(override.disabled_hooks ?? []),
      ]),
    ],
    // disabled_mcps, disabled_commands, disabled_skills 同理...
  }
}
```

合并策略可以总结为：
- **标量字段**（`string`、`boolean`、`number`）：项目配置直接覆盖用户配置
- **对象字段**（`agents`、`categories`）：深度合并，项目配置中的具体字段覆盖用户配置中的同名字段
- **数组字段**（`disabled_*`）：两层配置的数组取**并集**（且去重），即任何一层禁用了某项，最终结果中该项就被禁用

### 配置迁移

oh-my-opencode 还实现了**配置自动迁移**机制。随着版本升级，某些配置项的名称或结构可能发生变化。迁移系统会在配置加载时自动将旧格式转换为新格式：

```typescript
// 加载配置时自动迁移
const rawConfig = parseJsonc<Record<string, unknown>>(content)
migrateConfigFile(configPath, rawConfig)
```

迁移系统覆盖了四个方面：
- **Agent 名称迁移**：如将旧版 Agent 名称映射到新名称
- **Hook 名称迁移**：如将旧版 Hook 名称映射到新名称
- **模型版本迁移**：如将 `claude-3.5-sonnet` 自动升级为 `claude-4-sonnet`
- **Agent 配置到 Category 迁移**：将旧的 `model` 直接配置迁移为新的 `category` 间接配置

## 15.2.3 `OhMyOpenCodeConfig` 配置 Schema

oh-my-opencode 的配置使用 Zod Schema 定义，这保证了类型安全和运行时验证。主 Schema 定义在 `config/schema/oh-my-opencode-config.ts`：

```typescript
// oh-my-opencode/src/config/schema/oh-my-opencode-config.ts
export const OhMyOpenCodeConfigSchema = z.object({
  $schema: z.string().optional(),

  // === 功能开关 ===
  new_task_system_enabled: z.boolean().optional(),
  default_run_agent: z.string().optional(),

  // === 禁用列表 ===
  disabled_mcps: z.array(AnyMcpNameSchema).optional(),
  disabled_agents: z.array(BuiltinAgentNameSchema).optional(),
  disabled_skills: z.array(BuiltinSkillNameSchema).optional(),
  disabled_hooks: z.array(HookNameSchema).optional(),
  disabled_commands: z.array(BuiltinCommandNameSchema).optional(),
  disabled_tools: z.array(z.string()).optional(),

  // === Agent 配置 ===
  agents: AgentOverridesSchema.optional(),
  categories: CategoriesConfigSchema.optional(),
  sisyphus_agent: SisyphusAgentConfigSchema.optional(),
  sisyphus: SisyphusConfigSchema.optional(),

  // === 功能模块配置 ===
  claude_code: ClaudeCodeConfigSchema.optional(),
  comment_checker: CommentCheckerConfigSchema.optional(),
  skills: SkillsConfigSchema.optional(),
  ralph_loop: RalphLoopConfigSchema.optional(),
  background_task: BackgroundTaskConfigSchema.optional(),
  notification: NotificationConfigSchema.optional(),
  babysitting: BabysittingConfigSchema.optional(),
  git_master: GitMasterConfigSchema.optional(),
  browser_automation_engine: BrowserAutomationConfigSchema.optional(),
  websearch: WebsearchConfigSchema.optional(),
  tmux: TmuxConfigSchema.optional(),

  // === 实验性功能 ===
  experimental: ExperimentalConfigSchema.optional(),
  auto_update: z.boolean().optional(),

  // === 内部状态 ===
  _migrations: z.array(z.string()).optional(),
})
```

### Agent 覆盖配置

每个 Agent 的行为都可以通过配置进行细粒度的覆盖：

```typescript
// oh-my-opencode/src/config/schema/agent-overrides.ts
export const AgentOverrideConfigSchema = z.object({
  category: z.string().optional(),         // 继承的 Category
  variant: z.string().optional(),          // Agent 变体
  skills: z.array(z.string()).optional(),  // 注入的 Skill 列表
  temperature: z.number().min(0).max(2).optional(),
  top_p: z.number().min(0).max(1).optional(),
  prompt: z.string().optional(),           // 完全替换 Prompt
  prompt_append: z.string().optional(),    // 追加 Prompt
  tools: z.record(z.string(), z.boolean()).optional(),  // 工具开关
  disable: z.boolean().optional(),         // 禁用整个 Agent
  description: z.string().optional(),
  mode: z.enum(["subagent", "primary", "all"]).optional(),
  color: z.string().regex(/^#[0-9A-Fa-f]{6}$/).optional(),
  maxTokens: z.number().optional(),
  thinking: z.object({                     // 扩展思考（Anthropic）
    type: z.enum(["enabled", "disabled"]),
    budgetTokens: z.number().optional(),
  }).optional(),
  reasoningEffort: z.enum(["low", "medium", "high", "xhigh"]).optional(),
  textVerbosity: z.enum(["low", "medium", "high"]).optional(),
  providerOptions: z.record(z.string(), z.unknown()).optional(),
})

// 可覆盖的 Agent 列表
export const AgentOverridesSchema = z.object({
  build: AgentOverrideConfigSchema.optional(),
  plan: AgentOverrideConfigSchema.optional(),
  sisyphus: AgentOverrideConfigSchema.optional(),
  hephaestus: AgentOverrideConfigSchema.optional(),
  "sisyphus-junior": AgentOverrideConfigSchema.optional(),
  prometheus: AgentOverrideConfigSchema.optional(),
  metis: AgentOverrideConfigSchema.optional(),
  momus: AgentOverrideConfigSchema.optional(),
  oracle: AgentOverrideConfigSchema.optional(),
  librarian: AgentOverrideConfigSchema.optional(),
  explore: AgentOverrideConfigSchema.optional(),
  "multimodal-looker": AgentOverrideConfigSchema.optional(),
  atlas: AgentOverrideConfigSchema.optional(),
})
```

一个典型的 Agent 覆盖配置示例：

```jsonc
// .opencode/oh-my-opencode.jsonc
{
  "agents": {
    "oracle": {
      "category": "ultrabrain",        // 使用 ultrabrain 类别的模型
      "temperature": 0.3,              // 降低随机性
      "prompt_append": "Always respond in Chinese.",  // 追加指令
      "thinking": {
        "type": "enabled",
        "budgetTokens": 10000          // 允许 10K token 的深度思考
      }
    },
    "explore": {
      "category": "quick",             // 使用快速类别（便宜模型）
      "tools": {
        "bash": false                  // 禁止 Explore Agent 使用 Bash
      }
    }
  }
}
```

### 后台任务配置

后台 Agent 并发控制是 oh-my-opencode 的关键配置之一：

```typescript
// oh-my-opencode/src/config/schema/background-task.ts
export const BackgroundTaskConfigSchema = z.object({
  // 默认并发数
  defaultConcurrency: z.number().min(1).optional(),
  // 按 Provider 设置并发上限
  providerConcurrency: z.record(z.string(), z.number().min(0)).optional(),
  // 按模型设置并发上限
  modelConcurrency: z.record(z.string(), z.number().min(0)).optional(),
  // 空闲超时（毫秒），超时的任务会被中断（默认 3 分钟）
  staleTimeoutMs: z.number().min(60000).optional(),
  // 未收到任何进度更新的超时（默认 10 分钟）
  messageStalenessTimeoutMs: z.number().min(60000).optional(),
})
```

这允许用户根据自己的 API 配额精确控制并发：

```jsonc
{
  "background_task": {
    "defaultConcurrency": 3,
    "providerConcurrency": {
      "anthropic": 2,    // Anthropic API 最多同时 2 个请求
      "openai": 5        // OpenAI API 最多同时 5 个请求
    },
    "staleTimeoutMs": 300000  // 5 分钟无活动则超时
  }
}
```

### 内置 Agent 与 Skill 的枚举类型

配置的类型安全不仅体现在结构上，还体现在枚举值上。oh-my-opencode 为所有内置 Agent 和 Skill 定义了严格的枚举 Schema：

```typescript
// oh-my-opencode/src/config/schema/agent-names.ts
export const BuiltinAgentNameSchema = z.enum([
  "sisyphus", "hephaestus", "prometheus", "oracle",
  "librarian", "explore", "multimodal-looker",
  "metis", "momus", "atlas",
])

export const BuiltinSkillNameSchema = z.enum([
  "playwright", "agent-browser", "dev-browser",
  "frontend-ui-ux", "git-master",
])
```

这意味着如果用户在 `disabled_agents` 中写了一个不存在的 Agent 名称，Zod 验证会在配置加载时报错（但由于部分容错解析，这不会导致整个配置失败）。

### Hook 名称枚举

所有 49 个可通过配置禁用的 Hook 都有枚举定义：

```typescript
// oh-my-opencode/src/config/schema/hooks.ts
export const HookNameSchema = z.enum([
  "todo-continuation-enforcer",
  "context-window-monitor",
  "session-recovery",
  "session-notification",
  "comment-checker",
  "tool-output-truncator",
  "directory-agents-injector",
  "preemptive-compaction",
  "rules-injector",
  "ralph-loop",
  "edit-error-recovery",
  "unstable-agent-babysitter",
  // ... 共 49 个
])
```

> **衍生解释：Schema-first 设计模式**
>
> oh-my-opencode 的配置系统采用了 "Schema-first"（模式优先）设计模式：先用 Zod 定义配置的完整结构和约束，再基于 Schema 生成类型和验证逻辑。
>
> 这种模式有几个关键优势：
>
> 1. **类型安全**：`z.infer<typeof Schema>` 自动生成 TypeScript 类型，无需手写 `interface`
> 2. **运行时验证**：Schema 不仅是类型定义，还是运行时验证器。用户的配置文件会在加载时被验证
> 3. **自文档化**：Schema 定义本身就是配置的文档——它精确描述了每个字段的类型、约束和默认值
> 4. **JSON Schema 生成**：Zod Schema 可以自动转换为标准 JSON Schema（oh-my-opencode 通过 `build:schema` 脚本实现），供 IDE 提供自动补全和验证
>
> 这与传统的"类型优先"模式（先写 TypeScript `interface`，再手写验证逻辑）形成对比。Schema-first 模式消除了类型定义和验证逻辑之间的不一致风险。

### 插件级全局状态

oh-my-opencode 维护了少量的插件级全局状态：

```typescript
// oh-my-opencode/src/plugin-state.ts
export interface ModelCacheState {
  modelContextLimitsCache: Map<string, number>  // 模型上下文窗口大小缓存
  anthropicContext1MEnabled: boolean             // 是否启用 Anthropic 100万 token 上下文
}

export function createModelCacheState(): ModelCacheState {
  return {
    modelContextLimitsCache: new Map<string, number>(),
    anthropicContext1MEnabled: false,
  }
}
```

这个状态在多个 Hook 之间共享。例如，`context-window-monitor` Hook 需要知道当前模型的上下文窗口大小来判断是否需要触发压缩，而 `preemptive-compaction` Hook 也需要同样的信息来决定何时先发制人地压缩上下文。通过共享 `ModelCacheState`，避免了重复查询模型信息的开销。

## 本节小结

oh-my-opencode 的初始化流程遵循**分阶段、链式依赖**的模式：

1. **环境准备**：注入认证、检测 tmux
2. **配置加载**：双层配置（用户级 + 项目级）合并，支持 JSONC 和部分容错
3. **Manager 创建**：tmux、后台 Agent、Skill MCP、配置处理器
4. **工具注册**（异步）：加载 Skill 上下文，创建 Category，注册 15 个工具
5. **Hook 创建**：核心 Hook + 续接 Hook + Skill Hook
6. **接口组装**：将所有能力映射到 OpenCode Plugin 接口

配置系统的三个设计亮点是：**部分容错解析**（单个字段出错不影响整体）、**智能合并策略**（对象深度合并、数组并集、标量覆盖）和 **Schema-first 设计**（Zod 同时充当类型定义和运行时验证器）。
