# 3.4 配置系统的分层设计

> **模型**: claude-opus-4-6 (anthropic/claude-opus-4-6)
> **生成日期**: 2025-02-17

---

配置系统是 OpenCode 中最精心设计的基础设施之一。它需要同时满足个人用户的灵活定制和企业环境的集中管控——这两个看似矛盾的需求通过分层设计得到了优雅的解决。

## 3.4.1 配置优先级链

OpenCode 定义了 7 层配置，优先级从低到高：

```
优先级（低 → 高）

1. Remote .well-known/opencode    ← 组织默认配置（通过域名发现）
   │
2. Global ~/.config/opencode/opencode.json   ← 用户全局配置
   │
3. Custom config (OPENCODE_CONFIG env)        ← 环境变量指定的配置文件
   │
4. Project opencode.json                      ← 项目根目录配置
   │
5. .opencode/ directory                       ← .opencode/ 目录下的配置
   │  ├── .opencode/agents/     Agent 定义
   │  ├── .opencode/commands/   自定义命令
   │  ├── .opencode/plugins/    插件
   │  └── .opencode/opencode.json 配置文件
   │
6. Inline config (OPENCODE_CONFIG_CONTENT)    ← 环境变量直接注入配置内容
   │
7. Managed config (/Library/Application Support/opencode)  ← 企业托管（最高优先级）
```

源码中的加载逻辑（`config/config.ts`）：

```typescript
export const state = Instance.state(async () => {
  // 配置加载顺序（从低到高优先级）
  let result: Info = {}

  // 1. Remote .well-known/opencode
  for (const [key, value] of Object.entries(auth)) {
    if (value.type === "wellknown") { /* 合并远程配置 */ }
  }

  // 2. Global config
  // 3. Custom config (OPENCODE_CONFIG)
  // 4. Project config
  // 5. .opencode directories
  // 6. Inline config (OPENCODE_CONFIG_CONTENT)
  // 7. Managed config (enterprise)

  return result
})
```

**设计意图**：

- **第 1 层**（Remote）：公司可以在域名下部署 `.well-known/opencode` 文件，为全组织提供默认配置
- **第 2-3 层**（Global + Custom）：个人偏好设置
- **第 4-5 层**（Project）：项目级别的定制，可以随代码版本控制
- **第 6 层**（Inline）：CI/CD 场景下通过环境变量注入配置
- **第 7 层**（Managed）：企业 IT 管理员强制覆盖的配置（如禁用某些功能、限制可用模型）

## 3.4.2 JSONC 解析与配置合并策略

OpenCode 支持 **JSONC**（JSON with Comments）格式的配置文件，这意味着用户可以在 JSON 中添加注释：

```jsonc
{
  // 使用 Claude 作为默认模型
  "model": "claude-sonnet-4-20250514",

  /* MCP 服务器配置 */
  "mcpServers": {
    "github": {
      "command": "mcp-server-github"
    }
  }
}
```

> **衍生概念：JSONC**
>
> JSON（JavaScript Object Notation）是一种轻量级数据交换格式，但标准 JSON 不支持注释。JSONC 是 JSON 的超集，允许使用 `//` 单行注释和 `/* */` 多行注释。VSCode 的所有配置文件（settings.json 等）都使用 JSONC 格式。OpenCode 使用 `jsonc-parser` 库来解析 JSONC。

**配置合并策略**：

多层配置最终需要合并为一个配置对象。OpenCode 使用深度合并（Deep Merge），但对数组字段有特殊处理：

```typescript
function mergeConfigConcatArrays(target: Info, source: Info): Info {
  const merged = mergeDeep(target, source)

  // 数组字段使用拼接而非替换
  if (target.plugin && source.plugin) {
    merged.plugin = Array.from(new Set([...target.plugin, ...source.plugin]))
  }
  if (target.instructions && source.instructions) {
    merged.instructions = Array.from(new Set([
      ...target.instructions,
      ...source.instructions
    ]))
  }
  return merged
}
```

这个设计选择值得注意：

- **对象字段**（如 `mcpServers`）：深度合并，高优先级覆盖低优先级
- **数组字段**（如 `plugin`、`instructions`）：拼接并去重，而不是覆盖

为什么数组要拼接？因为全局配置可能定义了一些基础 Plugin，项目配置可能添加了额外的 Plugin。如果项目配置直接覆盖全局配置的 `plugin` 数组，就会丢失全局 Plugin。拼接策略避免了这个问题。

## 3.4.3 Zod Schema 驱动的配置校验

OpenCode 使用 **Zod** 库来定义配置的 Schema，确保配置的类型安全：

> **衍生概念：Zod**
>
> Zod 是一个 TypeScript-first 的数据验证库。它允许你用 TypeScript 代码定义数据结构，然后在运行时验证数据是否符合该结构。
>
> ```typescript
> const UserSchema = z.object({
>   name: z.string(),
>   age: z.number().min(0),
>   email: z.string().email()
> })
>
> // 运行时验证
> UserSchema.parse({ name: "Alice", age: 25, email: "a@b.com" }) // ✓
> UserSchema.parse({ name: "Alice", age: -1 })                   // ✗ 抛出错误
> ```
>
> Zod 在 OpenCode 中的使用极为广泛——几乎所有数据模型都用 Zod 定义。这带来了两个好处：
> 1. **运行时类型安全**：所有外部输入（用户配置、API 请求、LLM 响应）都经过 Zod 校验
> 2. **类型推导**：通过 `z.infer<typeof Schema>`自动获取 TypeScript 类型，避免重复定义

配置的部分 Schema 定义：

```typescript
// 简化版，展示核心结构
const ConfigSchema = z.object({
  model: z.string().optional(),
  provider: z.record(z.string(), ProviderConfig).optional(),
  mcpServers: z.record(z.string(), McpServerConfig).optional(),
  permission: PermissionConfig.optional(),
  plugin: z.array(z.string()).optional(),
  instructions: z.array(z.string()).optional(),
  agent: z.record(z.string(), AgentConfig).optional(),
  snapshot: z.boolean().optional(),
  compaction: CompactionConfig.optional(),
  experimental: ExperimentalConfig.optional(),
})
```

## 3.4.4 Markdown 格式配置支持

除了 JSON 格式，OpenCode 还支持 Markdown 格式的配置（`config/markdown.ts`）。这主要用于 `AGENTS.md` 和 `CLAUDE.md` 指令文件——它们本质上是以 Markdown 格式存储的系统指令（System Prompt）。

这种设计让指令文件可以：
- 使用 Markdown 语法编写，可读性更好
- 随项目版本控制
- 包含代码块、列表等富文本格式

## 3.4.5 `Flag` 模块：环境变量与功能开关

`flag/flag.ts` 模块管理所有通过环境变量控制的功能开关：

```typescript
export namespace Flag {
  export const OPENCODE_CONFIG = process.env.OPENCODE_CONFIG
  export const OPENCODE_CONFIG_DIR = process.env.OPENCODE_CONFIG_DIR
  export const OPENCODE_CONFIG_CONTENT = process.env.OPENCODE_CONFIG_CONTENT
  export const OPENCODE_DISABLE_PROJECT_CONFIG = /* ... */
  export const OPENCODE_DISABLE_CLAUDE_CODE_PROMPT = /* ... */
  export const OPENCODE_DISABLE_DEFAULT_PLUGINS = /* ... */
  export const OPENCODE_EXPERIMENTAL_OUTPUT_TOKEN_MAX = /* ... */
  // ... 更多开关
}
```

环境变量前缀 `OPENCODE_` 确保了命名空间的唯一性。这些开关的主要用途：

1. **测试隔离**：如 `OPENCODE_TEST_HOME`、`OPENCODE_TEST_MANAGED_CONFIG_DIR`
2. **功能禁用**：如 `OPENCODE_DISABLE_PROJECT_CONFIG`（企业安全场景）
3. **实验性功能**：如 `OPENCODE_EXPERIMENTAL_OUTPUT_TOKEN_MAX`

**设计原则**：Flag 是比配置文件更低层级的控制机制，用于那些需要在配置系统初始化之前就确定的选项。例如 `OPENCODE_CONFIG` 指定了配置文件的路径——这个信息在配置加载之前就需要知道。

---

至此，第一部分（基础篇）的三章已经完整覆盖了 OpenCode 的背景、项目结构和整体架构。从下一章开始，我们将进入第二部分（核心架构篇），对 Session、Tool、Agent、Provider、MCP 五大核心模块进行源码级别的深入分析。
