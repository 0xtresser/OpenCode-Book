# 18.1 OpenCode 的关键设计决策回顾

> **模型**: claude-opus-4-6 (anthropic/claude-opus-4-6)
> **生成日期**: 2026-02-18

---

在前十七章中，我们从源码层面深入剖析了 OpenCode 的每一个核心模块。现在让我们退后一步，从**设计者的视角**审视这些技术选择——它们为什么这样做？解决了什么问题？有什么权衡？

本节提炼出 OpenCode 源码中最具特色的五个设计决策，帮助读者理解"好的 AI 工具架构应该长什么样"。

## 18.1.1 "一切皆 Namespace"——TypeScript Namespace 的大量使用

翻开 OpenCode 的任何一个核心模块，你都会看到这样的模式：

```typescript
// session/index.ts
export namespace Session {
  // 数据模型（Zod Schema）
  export const Info = z.object({
    id: Identifier.schema("session"),
    title: z.string(),
    // ...
  })
  export type Info = z.output<typeof Info>

  // 事件定义
  export const Event = {
    Created: BusEvent.define("session.created", z.object({ info: Info })),
    Updated: BusEvent.define("session.updated", z.object({ info: Info })),
  }

  // 业务函数
  export async function create(input?: CreateInput) { /* ... */ }
  export async function list() { /* ... */ }
  export async function get(id: string) { /* ... */ }
}
```

同样的模式出现在 `Agent`、`Provider`、`Tool`、`Permission`、`Snapshot`、`Bus`——几乎所有核心模块都是 Namespace 而非 Class。

### 为什么不用 Class？

传统的面向对象做法可能是这样的：

```typescript
// 传统 OOP 风格（OpenCode 没有这样做）
class SessionService {
  private storage: Storage
  private bus: EventBus

  constructor(storage: Storage, bus: EventBus) {
    this.storage = storage
    this.bus = bus
  }

  async create(input: CreateInput): Promise<Session> { /* ... */ }
  async get(id: string): Promise<Session> { /* ... */ }
}
```

OpenCode 选择 Namespace 而非 Class 的原因：

**1. 消除构造函数和依赖注入的复杂性**

Class 需要在某个地方被 `new` 出来，依赖关系需要手动或通过 DI 容器注入。Namespace 中的函数直接通过模块导入获取依赖，简化了初始化流程：

```typescript
// Namespace 风格：依赖通过模块导入解决
import { Storage } from "../storage"
import { Bus } from "../bus"

export namespace Session {
  export async function create() {
    await Storage.write(...)  // 直接使用，无需注入
    Bus.publish(Session.Event.Created, { info })
  }
}
```

**2. 类型和值的同名共存**

TypeScript 的 Namespace 允许同一个名字同时作为类型和值使用。这个特性被 OpenCode 大量利用：

```typescript
export namespace Session {
  // Info 既是值（Zod Schema 对象）...
  export const Info = z.object({ /* ... */ })
  // ...又是类型（从 Schema 推导出的 TypeScript 类型）
  export type Info = z.output<typeof Info>
}

// 使用时：
const session: Session.Info = await Session.get("ses_123")
//           ^-- 类型                   ^-- 值（函数）
```

这种"值-类型双重身份"让 API 非常整洁。

**3. 更好的 Tree-shaking**

Namespace 中未被引用的导出可以被构建工具移除。相比之下，Class 的实例方法即使未被调用，也会被打包到最终产物中。

**4. 符合函数式编程思维**

AI 编程助手的核心逻辑是数据流（消息进 → 处理 → 消息出），函数式风格更自然。Namespace 将相关的函数和类型分组，而不强制面向对象的继承体系。

### 权衡

这个选择也有代价：

- **测试时难以 Mock**：Namespace 中的函数直接调用其他模块，不如接口注入那样容易在测试中替换。
- **不熟悉的模式**：大多数 TypeScript 项目使用 Class 或普通模块导出，Namespace 用于业务逻辑并不常见。
- **循环依赖风险**：模块间直接导入（而非通过接口间接依赖），更容易形成循环依赖。

OpenCode 通过 `Instance.state()` 模式（见下节）和事件总线（第 11 章）来缓解这些问题。

## 18.1.2 "Instance State" 模式——无 Class 的状态管理

在没有 Class 的情况下，如何管理状态？OpenCode 发明了 `Instance.state()` 模式：

```typescript
// provider/provider.ts 中的使用
const state = Instance.state(
  // 初始化函数：第一次访问时执行
  async () => {
    const config = await Config.get()
    const providers: Record<string, Info> = {}
    const languages = new Map<string, LanguageModelV2>()
    // ...200+ 行初始化逻辑
    return { models: languages, providers, sdk, modelLoaders }
  },
  // 清理函数：实例销毁时执行
  async (state) => {
    // 释放资源
  }
)

// 使用：像调用函数一样获取状态
export async function list() {
  return state().then((s) => s.providers)
}
```

### 实现原理

`Instance.state()` 的核心实现在 `project/state.ts`（第 3.3.2 节）：

```typescript
export namespace State {
  const recordsByKey = new Map<string, Map<any, Entry>>()

  export function create<S>(
    root: () => string,  // 隔离键（通常是目录路径）
    init: () => S,        // 惰性初始化函数
    dispose?: (state: Awaited<S>) => Promise<void>  // 清理函数
  ) {
    return () => {
      const key = root()
      let entries = recordsByKey.get(key)
      if (!entries) {
        entries = new Map()
        recordsByKey.set(key, entries)
      }
      const exists = entries.get(init)
      if (exists) return exists.state as S
      // 第一次访问时执行 init()，之后复用缓存
      const state = init()
      entries.set(init, { state, dispose })
      return state
    }
  }
}
```

这本质上是一个**以目录路径为键的惰性单例模式**：

- **惰性初始化**：`init()` 只在第一次调用 `state()` 时执行，之后返回缓存
- **按目录隔离**：同一个模块在不同项目（目录）中有独立的状态实例
- **自动清理**：当 `Instance.dispose()` 被调用时，所有注册的 `dispose` 回调会被执行

### 为什么不用全局变量或单例 Class？

| 方案 | 问题 |
|------|------|
| 全局变量 | 多项目并发时状态冲突；无法自动清理 |
| 单例 Class | 同样无法按目录隔离；构造函数时机不确定 |
| `Instance.state()` | 按目录自动隔离；惰性初始化；自动清理 |

这个模式特别适合 OpenCode 的场景——Server 可能同时处理多个项目（不同目录）的请求，每个项目需要独立的 Provider 实例、Session 存储、Config 配置等。

## 18.1.3 "Zod 驱动"——Schema-first 的数据模型

OpenCode 中几乎看不到手写的 TypeScript 接口（`interface`），取而代之的是 **Zod Schema 作为 Single Source of Truth**：

```typescript
// 传统方式：接口 + 手动验证
interface Session {
  id: string
  title: string
  time: { created: number; updated: number }
}
function validate(data: unknown): Session { /* 手写验证逻辑 */ }

// OpenCode 方式：Zod Schema 一步到位
const Session = z.object({
  id: Identifier.schema("session"),
  title: z.string(),
  time: z.object({ created: z.number(), updated: z.number() }),
})
type Session = z.output<typeof Session>
// 验证：Session.parse(data) 或 Session.safeParse(data)
```

### 一个 Schema 派生多个用途

Zod Schema 在 OpenCode 中承担了远超"数据验证"的角色：

| 用途 | 实现方式 |
|------|---------|
| TypeScript 类型 | `z.output<typeof Schema>` 或 `z.infer<typeof Schema>` |
| 运行时验证 | `Schema.parse(data)` 抛异常，`Schema.safeParse(data)` 返回结果 |
| 函数参数校验 | `fn(schema, callback)` 包装器（`util/fn.ts`） |
| OpenAPI 规范 | Hono + Zod 自动生成 API 文档 |
| Tool 参数定义 | `tool.schema.string()` 直接传递给 LLM |
| 事件定义 | `BusEvent.define("name", schema)` 类型安全的事件 |
| 配置校验 | Config 使用 Zod Schema 校验 `opencode.json` |

**`fn()` 包装器**是一个特别精巧的设计（`util/fn.ts`）：

```typescript
export function fn<T extends z.ZodType, Result>(
  schema: T,
  cb: (input: z.infer<T>) => Result
) {
  const result = (input: z.infer<T>) => {
    const parsed = schema.parse(input)  // 运行时验证
    return cb(parsed)
  }
  result.force = (input: z.infer<T>) => cb(input)  // 跳过验证（性能场景）
  result.schema = schema  // 暴露 Schema 供外部内省
  return result
}

// 使用
export const create = fn(
  z.object({ title: z.string().optional() }),
  async (input) => {
    // input 已经过验证，类型安全
  }
)
create.schema // 可以读取参数 Schema，用于生成文档
```

### Schema-first 的哲学

这种模式的核心理念是：**数据的形状（Shape）应该只定义一次，然后在类型系统、运行时验证、文档生成等所有场景中复用**。这消除了接口定义和验证逻辑之间的不一致，也减少了手动维护多份类型定义的负担。

## 18.1.4 "Txt 模板"——Prompt 与代码分离

OpenCode 的 Agent Prompt 存储在独立的 `.txt` 文件中：

```
packages/opencode/src/agent/prompt/
├── anthropic.txt       # Claude 系列的 System Prompt
├── beast.txt           # GPT 系列的 System Prompt
├── gemini.txt          # Gemini 系列的 System Prompt
├── qwen.txt            # 其他模型的 System Prompt
├── codex_header.txt    # GPT-5 的额外前缀
├── explore.txt         # Explore Agent 的 Prompt
├── compaction.txt      # 上下文压缩 Prompt
├── title.txt           # 标题生成 Prompt
└── summary.txt         # 摘要生成 Prompt
```

这些 `.txt` 文件在构建时作为字符串导入：

```typescript
import PROMPT_ANTHROPIC from "./prompt/anthropic.txt"
import PROMPT_EXPLORE from "./prompt/explore.txt"

// 使用时直接作为字符串
const systemPrompt = PROMPT_ANTHROPIC
```

### 为什么要分离？

**1. Prompt 的迭代频率远高于代码**

在开发 AI 应用的过程中，Prompt 的调整频率可能是代码的 10 倍以上。把 Prompt 放在独立文件中，让 Prompt 工程师（或 AI 自己）可以快速修改，而不需要理解 TypeScript 代码。

**2. 可读性**

一个好的 System Prompt 可能有几百行（`anthropic.txt` 就非常长）。把这些长文本嵌入 TypeScript 代码中，会严重影响代码的可读性。

**3. Git Diff 友好**

独立的 `.txt` 文件在 Git Diff 中一目了然——哪些 Prompt 被修改了、改了什么。如果 Prompt 混在 TypeScript 代码中，Diff 会被代码变更"淹没"。

**4. 多模型适配**

不同的 LLM 需要不同风格的 Prompt（第 6.4.1 节）。独立文件让模型适配变成"选择不同的 .txt 文件"，而非在代码中用大量 if-else。

### 工具描述也用 .txt

OpenCode 的每个内置工具也有对应的 `.txt` 描述文件（第 5.3.7 节），工具的 `description` 字段从这些文件中读取。这意味着工具对 LLM 的"说明书"可以独立于工具的执行逻辑来维护。

## 18.1.5 "嵌入式 Server"——CLI 工具的 Web 化趋势

OpenCode 表面上是一个 CLI 工具，但它内部运行着一个完整的 HTTP Server（基于 Hono 框架，第 3.1 节）：

```
用户终端
    │
    ▼
┌──────────┐     ┌──────────────────────────────┐
│  TUI     │────▶│  嵌入式 HTTP Server (Hono)   │
│ (Ink)    │     │                              │
└──────────┘     │  /session/* → Session API    │
                 │  /config/*  → Config API     │
┌──────────┐     │  /provider/* → Provider API  │
│  Web UI  │────▶│  /mcp/*    → MCP API        │
│(SolidJS) │     │  /events   → SSE 推送       │
└──────────┘     │  /doc      → OpenAPI 文档   │
                 └──────────────────────────────┘
┌──────────┐              │
│  VSCode  │──────────────┘
│  扩展    │
└──────────┘
```

### 为什么 CLI 需要 Server？

**1. 多客户端统一**

OpenCode 不只是 CLI——它还有 Web UI（`packages/app/`）、桌面应用（`packages/desktop/`）、VSCode 扩展（`sdks/vscode/`）。嵌入式 Server 提供统一的 API，所有客户端共享同一套业务逻辑。

**2. 关注点分离**

TUI 负责用户交互（渲染、输入处理），Server 负责业务逻辑（Session 管理、LLM 调用、工具执行）。这让两层可以独立发展——例如可以在不修改 Server 的情况下重写 TUI。

**3. 实时通信**

Server 通过 SSE（Server-Sent Events，第 3.1.4 节）向客户端推送实时事件——流式文本输出、工具调用状态变化、会话更新等。这比 TUI 直接轮询或回调要优雅得多。

**4. 可测试性**

API 路由可以用标准的 HTTP 测试工具进行集成测试，不需要启动完整的 TUI 环境。

**5. ACP（Agent Client Protocol）支持**

嵌入式 Server 使 OpenCode 可以作为 ACP Agent 被其他应用调用（第 16.3 节），这是纯 CLI 架构做不到的。

### 设计模式的普适性

这种"嵌入式 Server"的设计模式正在成为现代 CLI 工具的趋势。类似的例子包括：

- **Docker CLI**：实际通过 REST API 与 Docker Daemon 通信
- **kubectl**：通过 HTTP 与 Kubernetes API Server 交互
- **VS Code**：整个编辑器运行在 Electron 中，通过内部 IPC 通信

OpenCode 把这种模式应用到了 AI 编程助手领域，使得"终端优先"的设计理念不会限制其多端扩展的可能性。

---

这五个设计决策共同构成了 OpenCode 的"技术人格"——函数式而非面向对象、Schema 驱动而非接口驱动、数据分离而非混合编写、Server 化而非单体 CLI。它们不一定是"唯一正确"的选择，但在 AI 编程助手这个快速迭代的领域，这些选择让 OpenCode 具备了出色的可维护性和可扩展性。
